#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\options openright
\use_default_options false
\master ../thesis.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding T1
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Indice
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
In this chapter we propose an approach based on a traditional database (RDBMS
 database), we will use this approach to compare performance of NoSQL 
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 databases in 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Performance-Evaluation"

\end_inset

.
\begin_inset Newline newline
\end_inset

Of course, except for the database, we try to emulate the approaches of
 NoSQL 
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 databases explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:State-of-Art"

\end_inset

 and in 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:technologies"

\end_inset

.
 So we have local database replication (with 
\begin_inset Quotes fld
\end_inset

eventually consistency
\begin_inset Quotes frd
\end_inset

) but the central database with 
\begin_inset Quotes fld
\end_inset

strong consistency
\begin_inset Quotes frd
\end_inset

.
\begin_inset Newline newline
\end_inset

The architecture proposed could be implemented with any RDBMS that has an
 advanced trigger support.
 In fact even if in some cases we use a proprietary solution, an alternative
 (general) solution is provided.
\end_layout

\begin_layout Standard

\series bold
TODO it is like a kew value
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Technologies-traditional"

\end_inset

Technologies
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:PostgreeSQL"

\end_inset

PostgreeSQL
\end_layout

\begin_layout Standard
The RDBS are 
\begin_inset Quotes fld
\end_inset

CA
\begin_inset Quotes frd
\end_inset

 according to the 
\begin_inset Quotes fld
\end_inset

CAP
\begin_inset Quotes frd
\end_inset

 theorem explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Consistency,-Partition-tolerance"

\end_inset

 and shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:-Database-triangle"

\end_inset

, i.e.
 they don't support a partition of the data in efficient way.
 But of course they can be partitioned.
\series bold

\begin_inset Newline newline
\end_inset


\series default
Moreover they can be replicated according to structures explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Multi-Master-&-Master-Slaves"

\end_inset

: 
\begin_inset Quotes fld
\end_inset

multi master
\begin_inset Quotes frd
\end_inset

 or 
\begin_inset Quotes fld
\end_inset

master-slaves
\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Standard
PostgreeSQL 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.postgresql.org/
\end_layout

\end_inset


\end_layout

\end_inset

 is a powerful and used a database (so a lot of libraries are implemented).
 It can be partitioned 
\begin_inset CommandInset citation
LatexCommand cite
key "PostgrePartitioning"

\end_inset

 and replicated in a 
\begin_inset Quotes fld
\end_inset

multi-master
\begin_inset Quotes frd
\end_inset

 architecture (and so also 
\begin_inset Quotes fld
\end_inset

master-slaves
\begin_inset Quotes frd
\end_inset

) 
\begin_inset CommandInset citation
LatexCommand cite
key "PostgreReplication"

\end_inset

.
\end_layout

\begin_layout Standard
Moreover it has interesting characteristics that we will use in the next
 sections:
\end_layout

\begin_layout Itemize
PostgreSQL is a very flexible database that allows to use custom languages
 
\begin_inset CommandInset citation
LatexCommand cite
key "PostgreLanguages"

\end_inset

.
 One of them is PL/sh 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/petere/plsh
\end_layout

\end_inset


\end_layout

\end_inset

 a language that allows to execute shell commands, so we are able to call
 an external program.
\end_layout

\begin_layout Itemize
PostgreSQL has a feature to create in an easy way a sort of publish/subscribe
 system, it is a queue where you can publish messages and read them in the
 order, to do that NOTIFY 
\begin_inset CommandInset citation
LatexCommand cite
key "PostgreNotify"

\end_inset

 and LISTEN 
\begin_inset CommandInset citation
LatexCommand cite
key "PostgreListen"

\end_inset

 commands are used.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Redis"

\end_inset

Redis
\end_layout

\begin_layout Standard
Redis 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://redis.io/
\end_layout

\end_inset


\end_layout

\end_inset

 is a key-value storage in memory 
\begin_inset CommandInset citation
LatexCommand cite
key "CAPNoSQL"

\end_inset

, the data can be written to the disk every a fixed amount of time.
 It allows to do a lot of different things:
\end_layout

\begin_layout Itemize
Cache system 
\begin_inset CommandInset citation
LatexCommand cite
key "RedisCache"

\end_inset

.
\end_layout

\begin_layout Itemize
Publish/subscribe system 
\begin_inset CommandInset citation
LatexCommand cite
key "RedisPUBSUB"

\end_inset

.
\end_layout

\begin_layout Itemize
Queue system, using lists 
\begin_inset CommandInset citation
LatexCommand cite
key "RedisQueue,RedisDataTypes"

\end_inset

.
\end_layout

\begin_layout Itemize
Distributed lock system that can be used by external systems 
\begin_inset CommandInset citation
LatexCommand cite
key "RedisLock"

\end_inset

.
\end_layout

\begin_layout Standard
With the following features:
\end_layout

\begin_layout Itemize
Data partitioning support 
\begin_inset CommandInset citation
LatexCommand cite
key "RedisPartitioning"

\end_inset


\end_layout

\begin_layout Itemize
Everything (image, text, json and so on) can be insert as the 
\begin_inset Quotes fld
\end_inset

value
\begin_inset Quotes frd
\end_inset

 (key-value storage), with high storage limit (512 megabyte per value) 
\begin_inset CommandInset citation
LatexCommand cite
key "RedisDataTypes"

\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Quotes fld
\end_inset

master-slaves
\begin_inset Quotes frd
\end_inset

 replication support 
\begin_inset CommandInset citation
LatexCommand cite
key "RedisReplication"

\end_inset


\end_layout

\begin_layout Itemize

\series bold
TOODO CAP
\end_layout

\begin_layout Standard
Unfortunately to keep high performance data are not stored immediately in
 the disk, but they are written every one second (default configuration)
 
\begin_inset CommandInset citation
LatexCommand cite
key "RedisPersistance"

\end_inset

.
\end_layout

\begin_layout Standard

\series bold
DISTRIBUTION, CAP
\end_layout

\begin_layout Standard

\series bold
TODO reference to redis here and above
\end_layout

\begin_layout Standard

\series bold
TODO authentication
\end_layout

\begin_layout Standard

\series bold
data retrieve via lib, replication, id subscribe
\end_layout

\begin_layout Standard

\series bold
https://github.com/socketio/socket.io-p2p can be useful considering the realtime
 cited before
\end_layout

\begin_layout Standard

\series bold
distributed, there is no a global vision of the network, like a p2p I don't
 know all clients connected
\end_layout

\begin_layout Standard

\series bold
rooms equivalent in realtime tested, or analogous way to obtain security
\end_layout

\begin_layout Standard

\series bold
say that this is very cusotmizable stack
\end_layout

\begin_layout Standard

\series bold
postgree trigger on specific column as data level
\end_layout

\begin_layout Standard

\series bold
data granularity
\end_layout

\begin_layout Standard

\series bold
explain napsace and rooms used
\end_layout

\begin_layout Standard

\series bold
If the websocket dies Do I lose the joins?
\end_layout

\begin_layout Standard

\series bold
improve appendix config, make it uniform and fix address, explaining them
\end_layout

\begin_layout Standard

\series bold
channels and other things as websocket advantages that engine haven't
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Socket.io-architecture"

\end_inset

Socket.io
\end_layout

\begin_layout Standard

\series bold
TODO FIX
\end_layout

\begin_layout Standard
One of the most famous websocket server, written in javascript, is 
\begin_inset Quotes fld
\end_inset

socket.io
\begin_inset Quotes frd
\end_inset

 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://socket.io/
\end_layout

\end_inset


\end_layout

\end_inset

.
 It is built on top of 
\begin_inset Quotes fld
\end_inset

engine.io
\begin_inset Quotes frd
\end_inset

 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/socketio/engine.io
\end_layout

\end_inset


\end_layout

\end_inset

 that is like the transportation level in the ISO/OSI stack, it is very
 efficient but it is only websocket implementation.
 As we will see 
\begin_inset Quotes fld
\end_inset

socket.io
\begin_inset Quotes frd
\end_inset

 has a lot of integrations and native implementation (since the protocol
 is open 
\begin_inset CommandInset citation
LatexCommand cite
key "SocketIOProtocol"

\end_inset

) that make it the best choice for our tests.
 Furthermore it is the best open source websocket server 
\begin_inset CommandInset citation
LatexCommand cite
key "WebsocketServersComparison"

\end_inset

.
\end_layout

\begin_layout Standard
We will use 
\begin_inset Quotes fld
\end_inset

socket.io
\begin_inset Quotes frd
\end_inset

 for the following features:
\end_layout

\begin_layout Itemize
It allows to emit events to all subscribed clients to that event 
\begin_inset CommandInset citation
LatexCommand cite
key "SocketIOEmitEvent"

\end_inset

.
 So events are channels of a publish/subscribe system.
\begin_inset Newline newline
\end_inset

Also the client can send events that, generally, are caught only by the
 server.
 Of course, since it is publish/subscribe, there is no notification of successfu
lly delivery to the server (ack).
\end_layout

\begin_layout Itemize
Redis integration to create websocket cluster 
\begin_inset CommandInset citation
LatexCommand cite
key "SocketIORedis"

\end_inset


\series bold
 
\series default
, it is explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Redis"

\end_inset

.
\series bold
TODO check if ti is needed
\end_layout

\begin_layout Itemize
user/session support 
\begin_inset CommandInset citation
LatexCommand cite
key "SocketIOUsers"

\end_inset

.
\end_layout

\begin_layout Itemize
Messages are sent in FIFO order, an important property to have 
\begin_inset Quotes fld
\end_inset

eventually consistency
\begin_inset Quotes frd
\end_inset

 as we will see in the next sections.
\end_layout

\begin_layout Standard
So we can a have a distributed publish/subscribe with user/session support.
\end_layout

\begin_layout Standard

\series bold
TODO FIX under
\end_layout

\begin_layout Standard
Of course to simply the architecture we will use the websocket server for
 
\begin_inset Quotes fld
\end_inset

synchronous requests
\begin_inset Quotes frd
\end_inset

 explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:RESTful-Approach"

\end_inset

, instead of implement a RESTful server this because only 
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 retrieve is the object of our study.
 Of course to handle these request we have to write custom logic.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Architecture-traditional"

\end_inset

Architecture proposed
\end_layout

\begin_layout Standard
....
\end_layout

\begin_layout Standard
As we said in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Technologies-traditional"

\end_inset

 both postgreSQL and redis can be partitioned and/or replicated, but we
 do not do it for simplicity.
 In fact as we will see in 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Benchmarks-strategy"

\end_inset

 we will test the performance in replication, moreover since redis is very
 efficient (since it is in-memory database) it will not be the bottleneck.
\end_layout

\begin_layout Standard
While a NoSQL 
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 database offers a full stack solution (often with client local database
 support) here we have to define every aspect of the stack.
 So we implement what we have defined in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Realtime-retrieve"

\end_inset

 , client best practices explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Client-best-practices"

\end_inset

, related needed things and what can be useful to emulate NoSQL 
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 databases approach:
\end_layout

\begin_layout Itemize
RDBMS database: that must be scalable among nodes and trigger support to
 notify changes.
 It is providded byt...
 
\series bold
TODO
\end_layout

\begin_layout Itemize
Publish/Subscribe system: to publish notification of changes as explained
 in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Publish/Subscribe"

\end_inset

.
\end_layout

\begin_layout Itemize
Websocket server: for the reason explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:WebSocket"

\end_inset

.
\end_layout

\begin_layout Itemize
Input server: where receive data to sent to database.
\end_layout

\begin_layout Itemize
Custom logic level: An eventual level where introduce custom logic.
\end_layout

\begin_layout Itemize
Client framework/libraries: to communicate to the server (cluster).
\end_layout

\begin_layout Standard
We tried to use Ecmascript where it is possible for the same reasons explained
 in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Client-language"

\end_inset

, using event driven approach explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Event-driven-approach"

\end_inset

.
\end_layout

\begin_layout Standard
On github 
\series bold
TODO
\series default
 there are both code, configurations and vagrant installer scripts.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Database-architecture-traditional"

\end_inset

Database
\end_layout

\begin_layout Standard
We use postgreSQL (explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:PostgreeSQL"

\end_inset

).
 So the normal operations are guaranteed by it (it has good libraries),
 so the consistency is guaranteed by it.
\end_layout

\begin_layout Standard
So the only thing that we have to solve is the notifications of changes
 to an external system (a publish/subscribe system).
\begin_inset Newline newline
\end_inset

The trivial solution (and general) is a trigger that call an external program
 (that publish data on publish/subscribe system), this can be done easily
 using Pl/sh as shown in appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:PostgreSQL-realtime-retrieve"

\end_inset

.
 But the call to an external program is not so efficient (startup time).
\end_layout

\begin_layout Standard
So we can use another solution that is more efficient but not standard:
 PUBLISH/NOTIFY.
 The trigger publishes the message, then an external listener republishes
 them in the other publish/subscribe system.
\begin_inset Newline newline
\end_inset

So we have the following step when there is a change:
\end_layout

\begin_layout Enumerate
Trigger call publish on a predefined postgreSQL channel for each event.
\end_layout

\begin_layout Enumerate
A javascript listener listen on the same postgreSQL channel.
\end_layout

\begin_layout Enumerate
The javascript listener republish the same message on Publish/Subscribe
 system defined in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Publish/Subscribe-architecture-traditional"

\end_inset

.
 It set also namespace and rooms that we will see in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Publish/Subscribe-architecture-traditional"

\end_inset

.
\end_layout

\begin_layout Standard
There are a lot of examples useful for our use case, one of them (with javascrip
t listener) 
\begin_inset CommandInset citation
LatexCommand cite
key "PostgreNotifyListenExample"

\end_inset

 was modified and used in our final configuration published on github.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Publish/Subscribe-architecture-traditional"

\end_inset

Publish/Subscribe
\end_layout

\begin_layout Standard
We try to emulate the approach used in NoSQL 
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 databases explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Publish/subscribeNOSQL"

\end_inset

.
\end_layout

\begin_layout Standard
As we will seen in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Websocket-server-architecture-traditional"

\end_inset

 we use socket.io for websocket server.
 As said in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Socket.io-architecture"

\end_inset

 socket.io is a system built on top of the websocket system (engine.io), so
 the publish/subscribe broker server and the websocket server are int he
 same machine.
\end_layout

\begin_layout Standard
It implements a distributed (via redis) publish/subscribe, i.e.
 different Publish/Subscribe broker servers communicate through redis.
\end_layout

\begin_layout Standard
When a message is published on a broker server this replicate it on redis,
 then other broker servers read it and send it to subscribed clients.
 So the listener script described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Database-architecture-traditional"

\end_inset

 when publishes something simply write it on redis (without call any broker
 server) 
\begin_inset CommandInset citation
LatexCommand cite
key "SocketIOEmiter"

\end_inset

.
\begin_inset Newline newline
\end_inset

Everything is done automatically without custom configuration on broker
 server: every event (channel) used by the listener can be subscribed by
 the users.
\end_layout

\begin_layout Standard
Socket.io allows to manage channel at high level, we can use:
\end_layout

\begin_layout Itemize
Namespace 
\begin_inset CommandInset citation
LatexCommand cite
key "SocketIOChannels"

\end_inset

: we can use them to distinguish different tables.
 So we have same events identified unequivocally for different tables.
\end_layout

\begin_layout Itemize
Rooms
\begin_inset CommandInset citation
LatexCommand cite
key "SocketIOChannels"

\end_inset

: we can use them to create a sort of 
\begin_inset Quotes fld
\end_inset

subchannel
\begin_inset Quotes frd
\end_inset

, a client could be subscribed only to one room that contains only events
 related only to some rows.
 This can be very useful to set up permissions at row level.
 Of course a client can write and read only rooms where he is subscribed
 and only the server can subscribe it to rooms.
\begin_inset Newline newline
\end_inset

So to do that a custom logic is needed (explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Custom-Logic-architecture-traditional"

\end_inset

).
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Websocket-server-architecture-traditional"

\end_inset

Websocket server
\end_layout

\begin_layout Standard
As said in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Publish/Subscribe-architecture-traditional"

\end_inset

 we use socket.io that is built on top of a websocket system and the communicatio
n is done by events.
 Also the client (as said in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Socket.io-architecture"

\end_inset

) communicates through events.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Input-Server-architecture-traditional"

\end_inset

Input Server
\end_layout

\begin_layout Standard
As we said 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:RESTful-Approach"

\end_inset

 a good approach is using RESTful to communications that do not need to
 be 
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 events.
\end_layout

\begin_layout Standard
But for simplicity we can send also the data form client to servers using
 websocket.
 Using socketio (as we said in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Socket.io-architecture"

\end_inset

) also the client uses events approach that does not provide an successfully
 delivery notification system, of course we can develop an our system but
 for the tests that we have to do (as we will see in 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Benchmarks-strategy"

\end_inset

) this (ack of actions done by client) is not important.
\begin_inset Newline newline
\end_inset

So for every socketio event the server call actions on postgreSQL server,
 we will insert this logic in custom logic (that we will see in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Custom-Logic-architecture-traditional"

\end_inset

).
\end_layout

\begin_layout Standard
The important thing of this approach is that the write does not depend by
 redis (that has persistence problems as shown in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Redis"

\end_inset

) and the consistency of data is managed by postgreSQL.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Custom-Logic-architecture-traditional"

\end_inset

Custom Logic
\end_layout

\begin_layout Standard
With socket.io we can insert a custom logic for events send by client, a
 simple example is shown 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Custom-logic-appendix"

\end_inset

.
 But we can not modify events generated by others, in that case the socket.io
 servers act only like a 
\begin_inset Quotes fld
\end_inset

switch
\begin_inset Quotes frd
\end_inset

 of messages, i.e.
 in a socket.io node we cannot modify messages sent by postgreSQL listener.
\end_layout

\begin_layout Standard
The two main things to do in this level are:
\end_layout

\begin_layout Itemize
Manage subscriptions to rooms.
 This depends from the role of rooms.
\begin_inset Newline newline
\end_inset

But if we use them for authorizations a simple solution is catch an event
 (sent by client) 
\begin_inset Quotes fld
\end_inset

auth
\begin_inset Quotes frd
\end_inset

 where we subscribe that client only to some rows based on the authentication
 result.
 For example we can subscribe (join to a room) the client only to rows that
 he owns (i.e.
 owner_id field matching).
\end_layout

\begin_layout Itemize
Send data to database.
 We can define different events for different database operations and for
 each of them map he event with the database library method.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Client-library-and-architecture-traditional"

\end_inset

Client library and local database
\end_layout

\begin_layout Standard
As said in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Local-database"

\end_inset

 we have to create a local database that is the final interface of our client.
 So the client contact only it, the local database send data through websocket
 and receive notifications of changes through websocket as we said previously.
\end_layout

\begin_layout Standard
As explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Local-database"

\end_inset

 one common way to implement 
\begin_inset Quotes fld
\end_inset

local database
\begin_inset Quotes frd
\end_inset

 is 
\begin_inset Quotes fld
\end_inset

last Writer Win
\begin_inset Quotes frd
\end_inset

, this approach will be used.
 So the replication should be 
\begin_inset Quotes fld
\end_inset

eventually consistency
\begin_inset Quotes frd
\end_inset

.
 
\begin_inset Newline newline
\end_inset

So a local database implementation is an object that contains data and provide
 the read/write methods for user.
\end_layout

\begin_layout Standard
We have the following situations
\end_layout

\begin_layout Itemize
User calls write/update: local data are updated.
 At the same time the local database tries to update the remote servers
 until there are no network errors.
\end_layout

\begin_layout Itemize
Data are updated by the server: a callback is called and it updates the
 local data.
\end_layout

\begin_layout Standard
Often the data are modified by server: default values, data updated by triggers,
 constraints, id auto generated and so on.
 Since we write data on client database we have to implement all of them
 in the client, but to do that we have to create a sort of 
\begin_inset Quotes fld
\end_inset

SQL interpreter
\begin_inset Quotes frd
\end_inset

 on client.
 Of course if there are no network problems the issue could be solved waiting
 the answer of the server, but this means make the application not optimistic.
\end_layout

\begin_layout Standard
This issue is solved by other systems in the following ways (some of them
 are already implemented since they are NoSQL) :
\end_layout

\begin_layout Itemize
Simplify constraints (the client can replicate them easily)
\end_layout

\begin_layout Itemize
Simplify defaults (the client can replicate them easily)
\end_layout

\begin_layout Itemize
No triggers
\end_layout

\begin_layout Itemize
Unique ID that can be generated by client.
\end_layout

\begin_layout Standard
For our application and tests we can skip all things except ID, to solve
 it we can use an UUID (Universally unique identifier) 
\begin_inset CommandInset citation
LatexCommand cite
key "UUID"

\end_inset

 that can be easily generated by the client, socketio server and postgreSQL
 server.
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Section
Traditional technologies
\end_layout

\begin_layout Standard
Since the traditional technologies are not the topic of the thesis but are
 need only to compare the performance of realtime databases, we will shortly
 describe just one solution.
 One of the best solution, it is chosen using knowledges from the literature
 using opensource and widespread technologies.
\end_layout

\begin_layout Standard
While the realtime database offers on full stack solution (or you have just
 to do minor things) here we have to join different solutions that can have
 possible overlapping, the main module to cover are the following (for each
 of them a sub chapter is dedicated):
\end_layout

\begin_layout Itemize
aaaa
\end_layout

\begin_layout Standard
On appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Configurations"

\end_inset

 the configurations, custom code (e.g.
 triggers) and basic examples of the technologies used are shown; the entire
 section makes a full example.
 In fact, while the realtime database implements the full stack in an easy
 way, here we have to use different technologies and configure them to communica
te each other in efficient way.
\begin_inset Newline newline
\end_inset

While on appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Installers"

\end_inset

 the scripts to install the environments on different servers are shown.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Database"

\end_inset

Database
\end_layout

\begin_layout Standard

\series bold
postgresql cluster
\end_layout

\begin_layout Standard
PSQL.
 
\series bold
TODO listing highligthed
\end_layout

\begin_layout Standard

\series bold
TODO notify parameters, pass entire new?
\end_layout

\begin_layout Standard

\series bold
TODO improove -> stament update
\end_layout

\begin_layout Standard
AAAAA.
 Of course they are not SQL standard but we will use them to increase the
 performances.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
TODO test if it is casual consistency, what happens if I send two update
 in the meantime.
 Is there a lock evne in the trigger?
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:traditional-Publish/Subscribe"

\end_inset

Publish/Subscribe
\end_layout

\begin_layout Standard
As we will see on the proper section (
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Websocket-Server"

\end_inset

) the websocket server implements publish/subscribe, so a publish/subscribe
 system is not required for this purpose.
 However 
\begin_inset Quotes fld
\end_inset

redis
\begin_inset Quotes frd
\end_inset

, that is explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Redis"

\end_inset

, can be used as publish/subscribe.
\end_layout

\begin_layout Standard
Redis 
\end_layout

\begin_layout Standard
https://blog.heroku.com/javascript_in_your_postgres
\end_layout

\begin_layout Standard
aaa 
\begin_inset CommandInset citation
LatexCommand cite
key "CAPNoSQL"

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Websocket-Server"

\end_inset

Websocket Server
\end_layout

\begin_layout Subsubsection
Redis
\end_layout

\begin_layout Subsection
Custom Logic
\end_layout

\begin_layout Standard
Since the websocket server is written in javascript it is easy to customize
 it.
 This can be very useful if we want, for example, customize the user management
 using an api key system.
 The customization is very easy since everything is done via callbacks,
 on listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Socket.io-customization"

\end_inset

 a simple customization for a channel is shown: when a message on the channel
 
\begin_inset Quotes fld
\end_inset

chat message
\begin_inset Quotes frd
\end_inset

 is received the message reversed is retransmitted in the same channel.
\end_layout

\begin_layout Subsection
Client framework
\end_layout

\begin_layout Standard
\begin_inset Quotes fld
\end_inset

socket.io
\begin_inset Quotes frd
\end_inset

 has implemented a simple client framework, with the channel support, it
 is a event driven implementation explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Event-driven-approach"

\end_inset

.
 Of course we have to define 
\begin_inset Quotes fld
\end_inset

REST actions
\begin_inset Quotes frd
\end_inset

 and libraries to do them in a custom way (the approach is explained in
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:RESTful-Approach"

\end_inset

), we have also to create a local databases (explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Local-database"

\end_inset

).
\end_layout

\begin_layout Standard
The Client framework is like the server one shown in listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Socket.io-customization"

\end_inset

.
\end_layout

\end_body
\end_document
