#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\options openright
\use_default_options false
\master ../thesis.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding T1
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Indice
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
In this chapter we propose an approach based on a traditional database (RDBMS
 database), we will use this approach to compare the performance of NoSQL
 
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 databases in 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Performance-Evaluation"

\end_inset

.
\begin_inset Newline newline
\end_inset

Of course, except for the database, we try to emulate the approaches of
 NoSQL 
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 databases explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:State-of-Art"

\end_inset

 and in 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:technologies"

\end_inset

.
 So we have the local database replication (with 
\begin_inset Quotes fld
\end_inset

eventually consistency
\begin_inset Quotes frd
\end_inset

) but the central database with 
\begin_inset Quotes fld
\end_inset

strong consistency
\begin_inset Quotes frd
\end_inset

.
\begin_inset Newline newline
\end_inset

The architecture proposed could be implemented with any RDBMS that has an
 advanced trigger support.
 In fact even if in some cases we use a proprietary solution, an alternative
 (general) solution is provided.
\end_layout

\begin_layout Standard
We will give the needed technology background in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Technologies-traditional"

\end_inset

.
\begin_inset Newline newline
\end_inset

Then we will explain from a theoretical point of view the architecture proposed
 in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Architecture-traditional"

\end_inset

.
\begin_inset Newline newline
\end_inset

Then we will explain the implementation done in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Implementation"

\end_inset

.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Technologies-traditional"

\end_inset

Technologies Background
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:PostgreeSQL"

\end_inset

PostgreSQL
\end_layout

\begin_layout Standard
The RDBS are 
\begin_inset Quotes fld
\end_inset

CA
\begin_inset Quotes frd
\end_inset

 according to the 
\begin_inset Quotes fld
\end_inset

CAP
\begin_inset Quotes frd
\end_inset

 theorem explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Consistency,-Partition-tolerance"

\end_inset

 and shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:-Database-triangle"

\end_inset

, i.e.
 they do not support a partition of the data in an efficient way.
 But of course they can be partitioned.
\series bold

\begin_inset Newline newline
\end_inset


\series default
Moreover they can be replicated according to the structures explained in
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Multi-Master-&-Master-Slaves"

\end_inset

: 
\begin_inset Quotes fld
\end_inset

multi master
\begin_inset Quotes frd
\end_inset

 or 
\begin_inset Quotes fld
\end_inset

master-slaves
\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Standard
PostgreSQL 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.postgresql.org/
\end_layout

\end_inset


\end_layout

\end_inset

 is a powerful and used database (so a lot of libraries are implemented).
 It can be partitioned 
\begin_inset CommandInset citation
LatexCommand cite
key "PostgrePartitioning"

\end_inset

 and replicated in a 
\begin_inset Quotes fld
\end_inset

multi-master
\begin_inset Quotes frd
\end_inset

 architecture (and so also 
\begin_inset Quotes fld
\end_inset

master-slaves
\begin_inset Quotes frd
\end_inset

) 
\begin_inset CommandInset citation
LatexCommand cite
key "PostgreReplication"

\end_inset

.
\end_layout

\begin_layout Standard
Moreover it has interesting characteristics that we will use in the next
 sections:
\end_layout

\begin_layout Itemize
PostgreSQL is a very flexible database that allows to use custom languages
 
\begin_inset CommandInset citation
LatexCommand cite
key "PostgreLanguages"

\end_inset

.
 One of them is PL/sh 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/petere/plsh
\end_layout

\end_inset


\end_layout

\end_inset

 a language that allows to execute shell commands, so we are able to call
 an external program.
\end_layout

\begin_layout Itemize
PostgreSQL has a feature to create easily a sort of publish/subscribe system,
 it is a queue where you can publish messages and read them in order, to
 do that NOTIFY 
\begin_inset CommandInset citation
LatexCommand cite
key "PostgreNotify"

\end_inset

 and LISTEN 
\begin_inset CommandInset citation
LatexCommand cite
key "PostgreListen"

\end_inset

 commands are used.
 NOTIFY is really called only after the transaction is committed.
\end_layout

\begin_layout Standard
Moreover PostgreSQL has JSON as data type
\begin_inset CommandInset citation
LatexCommand cite
key "PostgreJSON"

\end_inset

, it could be useful but we do not use it to keep the approach standard.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Redis"

\end_inset

Redis
\end_layout

\begin_layout Standard
Redis 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://redis.io/
\end_layout

\end_inset


\end_layout

\end_inset

 is a key-value storage in memory 
\begin_inset CommandInset citation
LatexCommand cite
key "CAPNoSQL"

\end_inset

, data can be written to the disk every fixed amount of time.
 It allows to do a lot of different things:
\end_layout

\begin_layout Itemize
Cache system 
\begin_inset CommandInset citation
LatexCommand cite
key "RedisCache"

\end_inset

.
\end_layout

\begin_layout Itemize
Publish/subscribe system 
\begin_inset CommandInset citation
LatexCommand cite
key "RedisPUBSUB"

\end_inset

.
\end_layout

\begin_layout Itemize
Queue system, using lists 
\begin_inset CommandInset citation
LatexCommand cite
key "RedisQueue,RedisDataTypes"

\end_inset

.
\end_layout

\begin_layout Itemize
Distributed lock system that can be used by external systems 
\begin_inset CommandInset citation
LatexCommand cite
key "RedisLock"

\end_inset

.
\end_layout

\begin_layout Standard
With the following features:
\end_layout

\begin_layout Itemize
Data partitioning support 
\begin_inset CommandInset citation
LatexCommand cite
key "RedisPartitioning"

\end_inset


\end_layout

\begin_layout Itemize
Everything (image, text, json and so on) can be inserted as the 
\begin_inset Quotes fld
\end_inset

value
\begin_inset Quotes frd
\end_inset

 (key-value storage), with high storage limit (512 megabyte per value) 
\begin_inset CommandInset citation
LatexCommand cite
key "RedisDataTypes"

\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Quotes fld
\end_inset

master-slaves
\begin_inset Quotes frd
\end_inset

 replication support 
\begin_inset CommandInset citation
LatexCommand cite
key "RedisReplication"

\end_inset


\end_layout

\begin_layout Standard
Unfortunately to keep a high performance data are not stored immediately
 in the disk, but they are written every one second (default configuration)
 
\begin_inset CommandInset citation
LatexCommand cite
key "RedisPersistance"

\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Socket.io-architecture"

\end_inset

Socket.io
\end_layout

\begin_layout Standard
Socket.io 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://socket.io/
\end_layout

\end_inset


\end_layout

\end_inset

 is one of the most famous websocket server, written in javascript.
 It is built on top of 
\begin_inset Quotes fld
\end_inset

engine.io
\begin_inset Quotes frd
\end_inset

 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/socketio/engine.io
\end_layout

\end_inset


\end_layout

\end_inset

 that is like the transportation level in the ISO/OSI stack, it is very
 efficient but it is only a websocket implementation.
 As we will see socket.io has a lot of integrations and a native implementation
 (since the protocol is open 
\begin_inset CommandInset citation
LatexCommand cite
key "SocketIOProtocol"

\end_inset

) that make it the best choice for our tests.
 Furthermore it is the best open source websocket server 
\begin_inset CommandInset citation
LatexCommand cite
key "WebsocketServersComparison"

\end_inset

.
\end_layout

\begin_layout Standard
We will use socket.io for the following features:
\end_layout

\begin_layout Itemize
It allows to emit events to all the subscribed clients to that event 
\begin_inset CommandInset citation
LatexCommand cite
key "SocketIOEmitEvent"

\end_inset

.
 So events are channels of a publish/subscribe system.
\begin_inset Newline newline
\end_inset

Also the client can send events that, generally, are caught only by the
 server.
 Of course, since it is publish/subscribe, there is no notification of successfu
lly delivery to the server (ack).
\begin_inset Newline newline
\end_inset

So the approach to be used to work with it is the 
\begin_inset Quotes fld
\end_inset

event driven approach
\begin_inset Quotes frd
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Event-driven-approach"

\end_inset

.
\end_layout

\begin_layout Itemize
Redis integration to create websocket cluster 
\begin_inset CommandInset citation
LatexCommand cite
key "SocketIORedis"

\end_inset

, redis is explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Redis"

\end_inset

.
\end_layout

\begin_layout Itemize
User/session support 
\begin_inset CommandInset citation
LatexCommand cite
key "SocketIOUsers"

\end_inset

.
\end_layout

\begin_layout Itemize
Messages are sent in FIFO order, an important property to have 
\begin_inset Quotes fld
\end_inset

eventually consistency
\begin_inset Quotes frd
\end_inset

 as we will see in the next sections.
\end_layout

\begin_layout Itemize
P2P support 
\begin_inset CommandInset citation
LatexCommand cite
key "SocketIOP2P"

\end_inset

, it could be useful to implement a system like 
\begin_inset Quotes fld
\end_inset

gun.js
\begin_inset Quotes frd
\end_inset

 (explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Gun.js"

\end_inset

).
\end_layout

\begin_layout Standard
So we can a have a distributed publish/subscribe with user/session support.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Architecture-traditional"

\end_inset

Architecture proposed
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/traditional_architecture.png
	width 70col%
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Traditional-Architecture-propose"

\end_inset

Traditional Architecture Proposed
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In image 
\series bold

\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Traditional-Architecture-propose"

\end_inset


\series default
 we can see the architecture proposed, every part will be explained in the
 following sections.
\end_layout

\begin_layout Standard
We have also added an additional level: load balancer/CDN (content delivery
 network) or other analogous things.
 It can be used to scale 
\begin_inset CommandInset citation
LatexCommand cite
key "RFCCN,CDNBook"

\end_inset

, to route users to different socket.io servers.
 
\begin_inset Newline newline
\end_inset

In fact as we will see in the architecture that we propose we can have more
 than one socket.io server, but there is no system to route users.
\begin_inset Newline newline
\end_inset

Since we do not need it in the tests phase (as we will see in 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Benchmarks-strategy"

\end_inset

), we skip this level to avoid to insert other levels to test.
\end_layout

\begin_layout Standard
As we said in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Technologies-traditional"

\end_inset

 both postgreSQL and redis can be partitioned and/or replicated, but we
 do not do it for simplicity.
 In fact as we will see in 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Benchmarks-strategy"

\end_inset

 we will test the performance in replication, moreover since redis is very
 efficient (since it is in-memory database) it will not be the bottleneck.
\end_layout

\begin_layout Standard
While a 
\begin_inset Quotes fld
\end_inset

CS-NoSQL
\begin_inset Quotes frd
\end_inset

 offers a full stack solution (often with client local database support)
 here we have to define every aspect of the stack.
 So we implement what we have defined in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Realtime-retrieve"

\end_inset

, client best practices explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Client-best-practices"

\end_inset

, related needed things and what can be useful to emulate 
\begin_inset Quotes fld
\end_inset

CS-NoSQL
\begin_inset Quotes frd
\end_inset

 approach:
\end_layout

\begin_layout Itemize
RDBMS database: that must be scalable among nodes and trigger support to
 notify changes.
 It is explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Database-architecture-traditional"

\end_inset


\end_layout

\begin_layout Itemize
Publish/Subscribe system: to publish notifications of changes as explained.
 It is explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Publish/Subscribe-architecture-traditional"

\end_inset

.
\end_layout

\begin_layout Itemize
Websocket server: for the reason explained.
 It is explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Websocket-server-architecture-traditional"

\end_inset

.
\end_layout

\begin_layout Itemize
Input server: where receiving data to be sent to the database.
 It is explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Input-Server-architecture-traditional"

\end_inset

.
\end_layout

\begin_layout Itemize
Custom logic level: an eventual level where to introduce custom logic.
 It is explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Custom-Logic-architecture-traditional"

\end_inset


\end_layout

\begin_layout Itemize
Client framework/libraries: to communicate to the server (cluster).
 It is explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Client-library-and-architecture-traditional"

\end_inset


\end_layout

\begin_layout Standard
In this solution we have a data granularity at a row level, since detailed
 granularity is not required by the further study that we will do.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Database-architecture-traditional"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "subsec:Database"

\end_inset

Database
\end_layout

\begin_layout Standard
We use postgreSQL (explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:PostgreeSQL"

\end_inset

).
 So the normal operations are guaranteed by it (it has good libraries),
 so the consistency is guaranteed by it.
\end_layout

\begin_layout Standard
So the only thing we have to solve is the notifications of changes to an
 external system (a publish/subscribe system).
\begin_inset Newline newline
\end_inset

The trivial solution (and general) is a trigger that calls an external program
 (that publishes data on publish/subscribe system), this can be done easily
 using PL/sh as shown in appendix 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:PostgreSQL-realtime-retrieve"

\end_inset

.
 But the call to an external program is not so efficient (startup time),
 moreover we should find a way to call the external program only after the
 commit.
\end_layout

\begin_layout Standard
So we can use another solution that is more efficient but not standard:
 PUBLISH/NOTIFY.
 The trigger publishes the message, then an external listener republishes
 them in the other publish/subscribe system.
\begin_inset Newline newline
\end_inset

So we have the following step when there is a change:
\end_layout

\begin_layout Enumerate
Trigger call publishes on a predefined postgreSQL channel for each event.
\end_layout

\begin_layout Enumerate
A javascript listener listens on the same postgreSQL channel.
\end_layout

\begin_layout Enumerate
The javascript listener republishes the same message on Publish/Subscribe
 system defined in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Publish/Subscribe-architecture-traditional"

\end_inset

.
 It also sets namespace and rooms that we will see in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Publish/Subscribe-architecture-traditional"

\end_inset

.
\end_layout

\begin_layout Standard
There are a lot of examples useful for our use case, one of them (with javascrip
t listener) 
\begin_inset CommandInset citation
LatexCommand cite
key "PostgreNotifyListenExample"

\end_inset

 was modified and used in our final configuration published on github.
\end_layout

\begin_layout Standard
We can see that this approach is like a 
\begin_inset Quotes fld
\end_inset

key-value
\begin_inset Quotes frd
\end_inset

 approach studied in 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:technologies"

\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Publish/Subscribe-architecture-traditional"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "subsec:traditional-Publish/Subscribe"

\end_inset

Publish/Subscribe
\end_layout

\begin_layout Standard
We try to emulate the approach used in 
\begin_inset Quotes fld
\end_inset

CS-NoSQL
\begin_inset Quotes frd
\end_inset

 explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Publish/subscribeNOSQL"

\end_inset

.
\end_layout

\begin_layout Standard
As we will see in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Websocket-server-architecture-traditional"

\end_inset

 we use socket.io for websocket server.
 As said in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Socket.io-architecture"

\end_inset

 socket.io is a system built on top of the websocket system (engine.io), so
 the publish/subscribe broker server and the websocket server are in the
 same machine.
\end_layout

\begin_layout Standard
It implements a distributed (via redis) publish/subscribe, i.e.
 different Publish/Subscribe broker servers communicate through redis.
 But in this way we do not know the status of the entire network, we do
 not know which brokers are connected.
\end_layout

\begin_layout Standard
When a message is published on a broker server this replicates it on redis,
 then other broker servers read it and send it to the subscribed clients.
 So the listener script described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Database-architecture-traditional"

\end_inset

 when publishes something simply writes it on redis (without call any broker
 server) 
\begin_inset CommandInset citation
LatexCommand cite
key "SocketIOEmiter"

\end_inset

.
\begin_inset Newline newline
\end_inset

Everything is done automatically without custom configuration on broker
 server: every event (channel) used by the listener can be subscribed by
 the users.
\end_layout

\begin_layout Standard
Socket.io allows to manage channel at high level, we can use:
\end_layout

\begin_layout Itemize
Namespaces 
\begin_inset CommandInset citation
LatexCommand cite
key "SocketIOChannels"

\end_inset

: we can use them to distinguish different tables.
 So we have the same events identified unequivocally for different tables.
\end_layout

\begin_layout Itemize
Rooms
\begin_inset CommandInset citation
LatexCommand cite
key "SocketIOChannels"

\end_inset

: we can use them to create a sort of 
\begin_inset Quotes fld
\end_inset

subchannel
\begin_inset Quotes frd
\end_inset

, a client could be subscribed only to one room that contains only events
 related only to some rows.
 This can be very useful to set up permissions at a row level.
 Of course a client can write and read only rooms where he is subscribed
 and only the server can subscribe it to rooms.
\begin_inset Newline newline
\end_inset

So to do that a custom logic is needed (explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Custom-Logic-architecture-traditional"

\end_inset

).
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Websocket-server-architecture-traditional"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "subsec:Websocket-Server"

\end_inset

Websocket server
\end_layout

\begin_layout Standard
As said in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Publish/Subscribe-architecture-traditional"

\end_inset

 we use socket.io that is built on top of a websocket system and the communicatio
n is done by events.
 Also the client (as said in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Socket.io-architecture"

\end_inset

) communicates through events.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Input-Server-architecture-traditional"

\end_inset

Input Server
\end_layout

\begin_layout Standard
As we said 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:RESTful-Approach"

\end_inset

 a good approach is to use RESTful to communications that do not need to
 be 
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 events (they are 
\begin_inset Quotes fld
\end_inset

synchronous requests
\begin_inset Quotes frd
\end_inset

).
\end_layout

\begin_layout Standard
But for simplicity we can send also the data form client to servers using
 websocket.
 Using socket.io (as we said in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Socket.io-architecture"

\end_inset

) also the client uses events approach that does not provide a successful
 delivery notification system, of course we can develop our system but for
 the tests that we have to do (as we will see in 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Benchmarks-strategy"

\end_inset

) this (ack of actions done by the client) is not important.
\begin_inset Newline newline
\end_inset

So for every socket.io event the server calls actions on postgreSQL server,
 we will insert this logic into the custom logic (that we will see in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Custom-Logic-architecture-traditional"

\end_inset

).
\end_layout

\begin_layout Standard
The important thing of this approach is that the writing does not depend
 on redis (that has persistence problems as shown in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Redis"

\end_inset

) and the consistency of data is managed by postgreSQL.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Custom-Logic-architecture-traditional"

\end_inset

Custom Logic
\end_layout

\begin_layout Standard
With socket.io we can insert a custom logic for events sent by the client,
 a simple example is shown 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Custom-logic-appendix"

\end_inset

.
 But we cannot modify events generated by others, in that case the socket.io
 servers act only like a 
\begin_inset Quotes fld
\end_inset

switch
\begin_inset Quotes frd
\end_inset

 of messages, i.e.
 in a socket.io node we cannot modify messages sent by postgreSQL listener.
\end_layout

\begin_layout Standard
The two main things to do in this level are:
\end_layout

\begin_layout Itemize
Manage subscriptions to rooms.
 This depends on the role of rooms.
\begin_inset Newline newline
\end_inset

But if we use them for authorizations a simple solution is catching an event
 (sent by client) 
\begin_inset Quotes fld
\end_inset

auth
\begin_inset Quotes frd
\end_inset

 where we subscribe that client only to some rows based on the authentication
 result.
 For example we can subscribe (join to a room) the client only to rows that
 he owns (i.e.
 owner_id field matching).
\end_layout

\begin_layout Itemize
Send data to database.
 We can define different events for different database operations and for
 each of them map the event with the database library method.
\end_layout

\begin_layout Standard
The only problem with this solution is that there is no persistence of data
 associated to a client.
 If the socket.io server dies, if the client changes the server (if we have
 load balance organization) or if the connection is interrupted (and then
 reestablished) the data associated to a client are lost.
\begin_inset Newline newline
\end_inset

The only critical thing in our approach is the authentication, in fact if
 we are able to identify the client we can store other things (like rooms
 joined) in other places.
 A simple and standard approach, that is not centralized (so it does not
 need persistence), to authenticate clients is JWT (Json Web Token) 
\begin_inset CommandInset citation
LatexCommand cite
key "JWT"

\end_inset

.
 Eventually a resynchronization of data is needed (for messages lost during
 the down) but even if we do not implement it the solution remains 
\begin_inset Quotes fld
\end_inset

eventually consistency
\begin_inset Quotes frd
\end_inset

 
\begin_inset Newline newline
\end_inset

Of course for the topic of the thesis it is not needed to develop this,
 in fact we need just to test performances as shown in 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Benchmarks-strategy"

\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Client-library-and-architecture-traditional"

\end_inset

Client library and local database
\end_layout

\begin_layout Standard
As said in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Local-database"

\end_inset

 we have to create a local database that is the final interface of our client.
 So the client contacts only it, the local database sends data through websocket
 and receives notifications of changes through websocket as we said previously.
\end_layout

\begin_layout Standard
As explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Local-database"

\end_inset

 one common way to implement 
\begin_inset Quotes fld
\end_inset

local database
\begin_inset Quotes frd
\end_inset

 is 
\begin_inset Quotes fld
\end_inset

last Writer Win
\begin_inset Quotes frd
\end_inset

, this approach will be used.
 So the replication should be 
\begin_inset Quotes fld
\end_inset

eventually consistency
\begin_inset Quotes frd
\end_inset

.
 
\begin_inset Newline newline
\end_inset

So a local database implementation is an object that contains data and provides
 the read/write methods for the user.
\end_layout

\begin_layout Standard
We have the following situations:
\end_layout

\begin_layout Itemize
User calls write/update: local data are updated.
 At the same time the local database tries to update the remote servers
 until there are no network errors.
\end_layout

\begin_layout Itemize
Data are updated by the server: a callback is called and it updates the
 local data.
\end_layout

\begin_layout Standard
Often data are modified by the server: default values, data updated by triggers,
 constraints, id auto generated and so on.
 Since we write data on the client database we have to implement all of
 them in the client, but to do that we have to create a sort of 
\begin_inset Quotes fld
\end_inset

SQL interpreter
\begin_inset Quotes frd
\end_inset

 on the client.
 Of course if there are no network problems the issue could be solved waiting
 for the answer of the server, but this means to make the application not
 optimistic.
\end_layout

\begin_layout Standard
This issue is solved by other systems in the following ways (some of them
 are already implemented since they are NoSQL):
\end_layout

\begin_layout Itemize
Simplify constraints (the client can replicate them easily).
\end_layout

\begin_layout Itemize
Simplify defaults (the client can replicate them easily).
\end_layout

\begin_layout Itemize
No triggers.
\end_layout

\begin_layout Itemize
Unique ID that can be generated by the client.
\end_layout

\begin_layout Standard
For our application and tests we can skip everything except for ID, to solve
 it we can use a UUID (Universally Unique Identifier) 
\begin_inset CommandInset citation
LatexCommand cite
key "UUID"

\end_inset

 that can be easily generated by the client, socket.io server and postgreSQL
 server.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Implementation"

\end_inset

Implementation
\end_layout

\begin_layout Standard
We tried to use Ecmascript where it is possible for the same reasons explained
 in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Client-language"

\end_inset

, using event driven approach explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Event-driven-approach"

\end_inset

.
\end_layout

\begin_layout Standard
On github 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/carduz/master-thesis-source/tree/master/proposed_solution
\end_layout

\end_inset


\end_layout

\end_inset

 there are both code, configurations and vagrant installer scripts.
 The installation instructions can be found in the readme.
\begin_inset Newline newline
\end_inset

We used also 
\begin_inset Quotes fld
\end_inset

promise
\begin_inset Quotes frd
\end_inset

 pattern 
\begin_inset CommandInset citation
LatexCommand cite
key "PromiseJS"

\end_inset

 to make callbacks more readable.
\end_layout

\begin_layout Standard
Now we analyze quickly the structure of the code, of course everything is
 commented so we explain only the critical points.
\begin_inset Newline newline
\end_inset

We have the following main objects:
\end_layout

\begin_layout Itemize
Database, sample table, trigger with related functions, these are very simple
 and follow the structure explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Database-architecture-traditional"

\end_inset

.
 As we said previously the database is neither distributed nor partitioned.
\end_layout

\begin_layout Itemize
Database listener, this is very simple and follow the structure explained
 in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Database-architecture-traditional"

\end_inset

.
 We inserted it in a separated section because (as we have done in the vagrant
 installer scripts) it can be deployed on another machine (only one machine,
 in fact it cannot be distributed), of course it can be deployed in the
 same machine of the database.
\begin_inset Newline newline
\end_inset

This listener sends an event to clients of a specif room (we will see logic
 of rooms in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Server-traditional"

\end_inset

) for every action done in the table (
\begin_inset Quotes fld
\end_inset

insert
\begin_inset Quotes frd
\end_inset

, 
\begin_inset Quotes fld
\end_inset

update
\begin_inset Quotes frd
\end_inset

, 
\begin_inset Quotes fld
\end_inset

delete
\begin_inset Quotes frd
\end_inset

) as socket.io event (the event name is the SQL action).
 As we said previously the table is specified as namespace.
\end_layout

\begin_layout Itemize
Redis server, this does not require additional codes, so only vagrant installer
 script is provided.
\end_layout

\begin_layout Itemize
Websocket server, this will be explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Server-traditional"

\end_inset

 since it is very complex.
 This can be distributed using a load balance as we said in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Architecture-traditional"

\end_inset

, but only the installer script of a single machine is provided (no load
 balancer script) since we do not want to test load balancer (that means
 another level to test) as we will see in 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Benchmarks-strategy"

\end_inset

.
\end_layout

\begin_layout Itemize
Client, this will be explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Client-traditional"

\end_inset

.
\end_layout

\begin_layout Standard
All things explained previously (in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Technologies-traditional"

\end_inset

 and in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Architecture-traditional"

\end_inset

) are implicit and are not linked in the next sections.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Server-traditional"

\end_inset

Websocket Server
\end_layout

\begin_layout Standard
The behavior is trivial, since much work is done automatically as we said
 previously.
\end_layout

\begin_layout Standard
We recap briefly what we have done:
\end_layout

\begin_layout Itemize
We define the same actions for all tables (specified in namespace via 
\begin_inset Quotes fld
\end_inset

of
\begin_inset Quotes frd
\end_inset

).
\end_layout

\begin_layout Itemize
We define 
\begin_inset Quotes fld
\end_inset

auth
\begin_inset Quotes frd
\end_inset

 event callback that identifies the client.
\end_layout

\begin_layout Itemize
We define 
\begin_inset Quotes fld
\end_inset

join
\begin_inset Quotes frd
\end_inset

 event callback that allows to a client to subscribe to rooms enabled for
 him.
 In this case we have provided a simple permission system where the room
 number is the owner_id of the row.
\begin_inset Newline newline
\end_inset

When a client joins a room all rows of that room are sent to the client
 (initial retrieve): emulating the 
\begin_inset Quotes fld
\end_inset

insert
\begin_inset Quotes frd
\end_inset

 event created by the database listener after having done a read all for
 that room.
 Of course the number of rows can be limited.
\end_layout

\begin_layout Itemize
We map client data events (add, put, delete) to sql functions (insert, update,
 delete) making some checks.
\begin_inset Newline newline
\end_inset

If there is an error (such as no permission) we discard the command and
 send the right command only to the client that has sent the request to
 update the local database of the client.
 For example if a client tries to add a row using an owner_id that is not
 enabled for him the server discards the add and sends a delete event to
 that client.
\end_layout

\begin_layout Standard
Using this approach, as said previously, the consistency of data modification
 is managed by postgreSQL and it is like any normal modern HTTP application,
 in fact data do not pass through redis in this phase.
\begin_inset Newline newline
\end_inset

The normal read is managed automatically and it is 
\begin_inset Quotes fld
\end_inset

eventually consistency
\begin_inset Quotes frd
\end_inset

 since the replication to local database is not synchronized but socket.io
 guarantees FIFO delivery.
\end_layout

\begin_layout Standard
There is only one critical point: what if there is a change during the initial
 retrieve considering that the client is not able to distinguish data (initial
 retrieve or other events)?
\end_layout

\begin_layout Standard
We could have the following situations:
\end_layout

\begin_layout Itemize
A notify event is called before the initial retrieve is executed.
 Updates and deletes are discarded since there is no data, insertions are
 added to local database but they cannot be newer than the data sent from
 the initial retrieve (for the same reason of the next point).
 Of course update/delete for rows added are considered.
 So it remains 
\begin_inset Quotes fld
\end_inset

eventually consistency
\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Itemize
A notify event is called (and so the websocket event) before the operation
 is committed and so visible to the 
\begin_inset Quotes fld
\end_inset

select
\begin_inset Quotes frd
\end_inset

 done meantime (this will cause select data older than notify event sent
 previously).
 This is impossible since the notify is really called only after commit.
\end_layout

\begin_layout Itemize
A notify event is called during the sending of initial data to the client.
 Since socket.io is executed in the same thread and delivery is FIFO, the
 sending of initial data is done before the new ones.
\end_layout

\begin_layout Itemize
A notify change arrives before the answer of the select (but the select
 command was already sent).
 In this case we lose the change, but it is still 
\begin_inset Quotes fld
\end_inset

eventually consistency
\begin_inset Quotes frd
\end_inset

.
 Of course improvements such as queue of events locked (until initial retrieve
 is finished) are good, but are not implemented to keep the simplicity of
 the code.
\end_layout

\begin_layout Standard
Recap (< means 
\begin_inset Quotes fld
\end_inset

called before
\begin_inset Quotes frd
\end_inset

):
\end_layout

\begin_layout Itemize
events < initial retrieve: they are not a problem since they are discarded
 or cause 
\begin_inset Quotes fld
\end_inset

eventually consistency
\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Itemize
events > initial retrieve: they are sent after initial retrieve.
\end_layout

\begin_layout Itemize
events during initial retrieve: we can lose something but we keep 
\begin_inset Quotes fld
\end_inset

casually consistency
\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Client-traditional"

\end_inset

Client
\end_layout

\begin_layout Standard
We have two main classes:
\end_layout

\begin_layout Itemize
General Local database:
\end_layout

\begin_deeper
\begin_layout Itemize
Keep a local copy of data
\end_layout

\begin_layout Itemize
When a change is requested, it updates local data then sends update to the
 server (retrying to send it if there are network delays).
\end_layout

\begin_layout Itemize
When a notification of change is received it updates local data and calls
 a callback that says that data were updated.
\end_layout

\begin_layout Itemize
As explained previously it adds a UUID to each row created.
\end_layout

\end_deeper
\begin_layout Itemize
Socket.io client: this class simply maps to socket.io commands functions and
 callbacks that 
\begin_inset Quotes fld
\end_inset

local database
\begin_inset Quotes frd
\end_inset

 wants
\end_layout

\begin_layout Standard
Of course the final client interacts only with the local database.
\end_layout

\end_body
\end_document
