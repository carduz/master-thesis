#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\options openright
\use_default_options false
\master thesis.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding T1
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Indice
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
L’introduzione deve essere atomica, quindi non deve contenere né sottosezioni
 né paragrafi né altro.
 Il titolo, il sommario e l’introduzione devono sembrare e e delle scatole
 cinesi, nel senso che lette in quest’ordine devono progressivamente svelare
 informazioni sul contenuto per incatenare l’attenzione del lettore e indurlo
 a leggere l’opera fino in fondo.
 L’introduzione deve essere tripartita, non graficamente ma logicamente.
\end_layout

\end_inset


\emph on

\begin_inset Note Note
status open

\begin_layout Plain Layout

\emph on
Inquadramento generale
\end_layout

\begin_layout Plain Layout
La prima parte contiene una frase che spiega l’area generale dove si svolge
 il lavoro; una che spiega la sottoarea più specifica dove si svolge il
 lavoro e la terza, che dovrebbe cominciare con le seguenti parole
\begin_inset Quotes fld
\end_inset

lo scopo della tesi è \SpecialChar ldots

\begin_inset Quotes frd
\end_inset

, illustra l’obbiettivo del lavoro.
 Poi vi devono essere una o due e frasi che contengano una breve spiegazione
 di cosa e come è stato fatto, e delle attività sperimentali, dei risultati
 ottenuti con una valutazione e degli a sviluppi futuri.
 La prima parte deve essere circa una facciata e mezza o due.
\end_layout

\end_inset


\emph default

\begin_inset Note Note
status open

\begin_layout Plain Layout

\emph on
Breve descrizione del lavoro
\end_layout

\begin_layout Plain Layout
La seconda parte deve essere una esplosione della prima e deve quindi mostrare
 in maniera pi` esplicita l’area dove si svolge il lavoro, le fonti u bibliograf
iche pi` importanti su cui si fonda il lavoro in maniera sintetica u (una
 pagina) evidenziando i lavori in letteratura che presentano attinenza con
 il lavoro affrontato in modo da mostrare da dove e perché è sorta la tematica
 di studio.
 Poi si mostrano esplicitamente le realizzazioni, le direttive future di
 ricerca, quali sono i problemi aperti e quali quelli affrontati e si ripete
 lo scopo della tesi.
 Questa parte deve essere piena di citazioni bibliografiche e deve essere
 lunga circa 4 facciate.
\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout

\emph on
Struttura della tesi
\end_layout

\begin_layout Plain Layout
La terza parte contiene la descrizione della struttura della tesi ed è organizza
ta nel modo seguente.
\begin_inset Quotes fld
\end_inset

La tesi è strutturata nel modo seguente
\begin_inset Quotes frd
\end_inset

.
 Nella sezione due si mostra\SpecialChar ldots
, nella sezione tre si illustra\SpecialChar ldots
 .
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In today's applications, data are increasing exponentially 
\begin_inset CommandInset citation
LatexCommand cite
key "bigData"

\end_inset

 and also need to be replicated on different devices in realtime, these
 different devices should be able to use them even if they are offline.
 So the devices need a local copy of the database available also offline
 called local database.
\begin_inset Newline newline
\end_inset

The typical device that uses this kind of application is a smartphone.
 But not only, also other web applications use them, such as collaborative
 softwares (like Google Docs) 
\begin_inset CommandInset citation
LatexCommand cite
key "realtimeGroupware"

\end_inset

.
\begin_inset Newline newline
\end_inset

So what we need is a database which allows processing big data and replicate
 itself among devices in realtime.
\end_layout

\begin_layout Standard
NoSQL databases were born to process big data efficiently 
\begin_inset CommandInset citation
LatexCommand cite
key "bigData2,CAPNoSQL"

\end_inset

.
 So solutions to replicate the databases in realtime are based on them,
 they can be opensource or proprietary in cloud located, one of the most
 famous cloud solution is firebase 
\begin_inset CommandInset citation
LatexCommand cite
key "firebaseArticle"

\end_inset

.
\begin_inset Newline newline
\end_inset

These solutions are not standardized, so there is no name even for them
 so we call them CS-NoSQL (client side NoSQL database).
\end_layout

\begin_layout Standard
Goal of this master thesis is to verify the performances of CS-NoSQL for
 the class of applications they are designed for.
 Another objective is exploring issues related to the development process,
 scalability and other related issues.
\begin_inset Newline newline
\end_inset

We analyze the theory behind these databases, then we classify and analyze
 the ones which have significant characteristics.
 We choose opensource systems since we can verify the characteristics declared
 by vendors, we can take more grained measurements of their performances
 (also low level data) and the technology behind them is more standard than
 the technology used by cloud systems.
\begin_inset Newline newline
\end_inset

Moreover, we develop an alternative system based on a traditional database
 that allows doing the same operations of native CS-NoSQL databases and
 we use it as a comparative system.
\begin_inset Newline newline
\end_inset

In order to test these specific databases we identify some significant classes
 of applications where they should perform efficiently, the classes of applicati
ons differ for elements that are typical of this kind of applications such
 as the number of clients subscribed, data structure and so on.
 Then we design a framework, since there is no test framework to analyze
 this kind of applications which considers issues related to them such as
 the number of clients subscribed.
 
\end_layout

\begin_layout Standard
We prove that our classical comparative system is more efficient in terms
 of performance, but also in terms of scalability and stability (CS-NoSQL
 are very unstable with a reasonable amount of data).
 In some cases, it is also 10x faster.
\begin_inset Newline newline
\end_inset

Besides CS-NoSQL are very efficient, in some cases, for development processes,
 in fact since they were born only for this purpose they are a full-stack
 environment (with other solutions we need to create the entire infrastructure)
 and this allows creating a simpler application with zero code.
 This is very common proprietary in cloud located systems but there is the
 disadvantage that it is a proprietary solution and if the system goes down
 or the cloud company fails all data are lost and there is no way to replicate
 the system in another server so a new development is needed.
 So lots of CS-NoSQL issues are related to the fact that solutions are proprieta
ry, we have issues like non standard way to run tests, non standard development
 processes and so on.
 This is a big cost for companies that want to use this kind of systems
 since they need a different training for each system used.
 Moreover, as we said previously, they have not so impressive performances.
 At the moment, only few companies use them but we expect big improvements
 on both main issues (performances and development process issues) in the
 next years when, probably, more native solutions will be implemented because
 the applications that need systems like that are increasing.
\end_layout

\begin_layout Standard
Since CS-NoSQL are not standardized and are new, their literature is poor
 but they are just a combination of technologies already well-studied.
 The problems related to their use is that we have only information from
 vendors.
 So we choose some theoretical information that are relevant and take these
 information from vendors (or if they are not available we try to deduct
 them from other sources such as the source code) for each CS-NoSQL that
 are relevant, both cloud and opensource.
 These information include: consistency, data granularity, distribution
 and partitioning, security issues and so on.
\begin_inset Newline newline
\end_inset

As said previously, we develop a comparing system that is based on a traditional
 database using postgreSQL and classical communication methods based on
 websockets.
\end_layout

\begin_layout Standard
We identify some interesting classes of applications that differ for relevant
 characteristics that are typical of this kind of applications.
 Even here, in order to do that we use the information provided by the vendors.
\begin_inset Newline newline
\end_inset

We design a test strategy and develop a test framework since there are no
 test frameworks for this kind of systems.
 This test framework allows testing the scalability and performances emulating
 the classes of applications analyzed before and take indices of performances
 that are very relevant for this kind of applications such as time needed
 to replicate a new information to all the clients.
 Of course we measure also classical measurements such as raw read/write
 speed.
\end_layout

\begin_layout Standard
Finally, we execute some benchmarks that are executed on identical virtual
 machines (distributed with the source code of the test framework) to make
 tests replicable and make them in a standard way.
 We execute tests on different combinations of machine characteristics to
 see scalability and bottlenecks of the systems to be tested.
 
\end_layout

\begin_layout Subsection*
Thesis organization
\end_layout

\begin_layout Standard
In Chapter 1, we present the background, all the knowledge that we need
 in order to understand the next topics.
 The main presented topics are HTTP and websocket protocol, basic concepts
 and issues of data in a distributed system (talking also about publish/subscrib
e and optimistic replication) and finally the concepts behind cloud computing
 from the user's point of view.
\begin_inset Newline newline
\end_inset

In Chapter 2, we describe the state of art of CS-NoSQL.
 Of course, as we said previously, there are no academic references to them,
 but references to technologies used, so we show NoSQL databases from a
 theoretical point of view with all the related aspects that we need (such
 as distribution).
 Then we show the best practices to implement the local database on the
 client side.
\begin_inset Newline newline
\end_inset

In Chapter 3, we analyze some real CS-NoSQL, both opensource and proprietary
 in cloud located ones.
 We classify them in a common way, as said previously, to compare them.
 Then we select a set of them to be used in the benchmark tests.
\begin_inset Newline newline
\end_inset

In Chapter 4, we show our proposed comparing solution.
 We describe all the elements to build it from the database to the client
 such as the system to deliver realtime messages and so on.
\begin_inset Newline newline
\end_inset

In Chapter 5, we analyze the classes of applications for which CS-NoSQL
 are designed according to vendors.
 We analyze use cases, and for each of them we show a real case study.
\begin_inset Newline newline
\end_inset

In Chapter 6, we define our strategy to run benchmark tests.
 We analyze what we need to do, what we need to measure, which tests we
 need to execute and we also shortly explain the framework we have implemented.
\begin_inset Newline newline
\end_inset

In Chapter 7, we show the results of benchmark tests and we comment them.
\begin_inset Newline newline
\end_inset

In Chapter 8, we present the conclusions of our master thesis and describe
 possible improvements and future research.
\end_layout

\end_body
\end_document
