#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\options openright
\use_default_options false
\master ../thesis.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding T1
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Indice
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
In this chapter we will see the idea behind benchmarks, whose results are
 published and commented in 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Benchmarks"

\end_inset

.
\end_layout

\begin_layout Standard
We will see how to test scalability in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Scaling-test"

\end_inset

.
\begin_inset Newline newline
\end_inset

Then we will quickly analyze the framework we realized for benchmarks in
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Custom-framework"

\end_inset

.
\begin_inset Newline newline
\end_inset

Then we will see how to test the classes of applications seen 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:class-of-applications"

\end_inset

.
\begin_inset Newline newline
\end_inset

Then we will see how to adapt different systems, that we analyzed in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Realtime-technologies"

\end_inset

 and in 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:A-traditional-approach"

\end_inset

, and what to consider.
\end_layout

\begin_layout Standard
All the things explained in the previous chapters are considered implicit.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Scaling-test"

\end_inset

Scaling Test
\end_layout

\begin_layout Standard
In this section we will see what we have to do to test the scaling of different
 solutions.
\end_layout

\begin_layout Standard
We will analyze the scaling that we will do and the reasons of those choices
 in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Scaling-tests"

\end_inset

.
\begin_inset Newline newline
\end_inset

Then we will see different test environments based on the previous choices
 in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Environments-test"

\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Scaling-tests"

\end_inset

Scaling
\end_layout

\begin_layout Standard
We know that NoSQL databases implement partitioning very efficiently 
\begin_inset CommandInset citation
LatexCommand cite
key "NoSQL"

\end_inset

.
 So we expect that with a lot of data that require partitioning the performance
 of NoSQL solutions would be much better than the traditional approach.
\begin_inset Newline newline
\end_inset

Moreover since, often, strong consistency constraints are relaxed, also
 the replication is more efficiently.
\begin_inset Newline newline
\end_inset

Both things bring to have horizontal scalability (also called out/in) 
\begin_inset CommandInset citation
LatexCommand cite
key "Scaling"

\end_inset

, since we increase the number of servers (not things like the power of
 them).
\begin_inset Newline newline
\end_inset

Furthermore, since 
\begin_inset Quotes fld
\end_inset

CS-NoSQL
\begin_inset Quotes frd
\end_inset

 are a full stack solution, also the internal realtime delivery server is
 scaled horizontally (it is scaled with the database).
\end_layout

\begin_layout Standard
So in order to keep simplicity, to make standard things (partition is implemente
d in different ways based on the data model) and to avoid to add an additional
 level to test, we decided to skip this part.
 So we test without horizontal scaling.
\begin_inset Newline newline
\end_inset

Moreover, since our topic is compared to these kinds of applications with
 a standard approach, if we test also the horizontal scaling we add another
 variable factor that can change our results.
\begin_inset Newline newline
\end_inset

For the same reason we do not scale the traditional approach that we proposed
 horizontally.
 Here the scaling we mean: partitioning and replication of postgreSQL server
 and replication of socket.io machines, redis is not a bottleneck so it does
 not need scaling.
\end_layout

\begin_layout Standard
But we will do a vertically scaling (also called up/down) 
\begin_inset CommandInset citation
LatexCommand cite
key "Scaling"

\end_inset

 that we will explain in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Environments-test"

\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Environments-test"

\end_inset

Environments
\end_layout

\begin_layout Standard
As we said in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Scaling-tests"

\end_inset

, we do only vertical scaling.
 So in this section we show different configurations that we want to test.
\begin_inset Newline newline
\end_inset

These configurations were found after some minor empirical tests.
 We have also set them to have the same maximum and minimum sum of resources
 used (counting not static servers).
\end_layout

\begin_layout Standard
As said previously, 
\begin_inset Quotes fld
\end_inset

CS-NoSQL
\begin_inset Quotes frd
\end_inset

 are a full stack solution implemented in just one server.
 So we can create a common environment for them, shown in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:NoSQL-realtime-databases-test"

\end_inset

.
\begin_inset Newline newline
\end_inset

While on the traditional approach proposed we have different servers.
 So they need an advanced discussion, shown in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Traditional-approach-test"

\end_inset

.
\end_layout

\begin_layout Standard
Socket.io and gun.js could be considered mono-thread so we do not scale the
 CPU.
 In fact we have a main thread where to execute callbacks and other operations,
 furthermore background operations (executed in other threads) in case of
 network delivery (background operations used by socket.io) are not CPU intensive
 
\begin_inset CommandInset citation
LatexCommand cite
key "NodeEventDriven"

\end_inset

.
\end_layout

\begin_layout Standard
To keep things more generally all the tests are done using virtual machines
 (using virtualbox 
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.virtualbox.org
\end_layout

\end_inset


\end_layout

\end_inset

)
\begin_inset CommandInset citation
LatexCommand cite
key "Virtualization"

\end_inset

 on the same physical machine.
 So all the components and technical characteristics are the same (such
 as RAM speed).
\series bold

\begin_inset Newline newline
\end_inset

Note
\series default
: with CPU we mean a standard modern CPU (i7 generation), of course for
 all servers the same CPU was used.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:NoSQL-realtime-databases-test"

\end_inset

CS-NoSQL
\end_layout

\begin_layout Standard
Since we have only one server we can simply follow the table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:NoSQL-realtime-database-envs"

\end_inset

.
 As we said previously gun.js can be considered mono-thread, so we can test
 it with just one CPU (so we will have only two cases based on the RAM).
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:NoSQL-realtime-database-envs"

\end_inset


\begin_inset Quotes fld
\end_inset

CS-NoSQL
\begin_inset Quotes frd
\end_inset

 test environments
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features booktabs="true" tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
NÂ°
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
RAM [GB]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
NÂ° CPU
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Traditional-approach-test"

\end_inset

Traditional approach
\end_layout

\begin_layout Standard
Here we have 4 servers, for each of them we use a virtual machine:
\end_layout

\begin_layout Itemize
PostgreSQL: this is a critical point and we will follow table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:postgresql-test"

\end_inset

.
\end_layout

\begin_layout Itemize
Redis: this is not a critical point, it is not also a thing to test.
 So we can consider it static, we use always a machine with 1CPU and 512MB
 RAM.
\end_layout

\begin_layout Itemize
Listener: this is not a critical point, it is not also a thing to test.
 So we can consider it static, we use always a machine with 1CPU and 512MB
 RAM.
\end_layout

\begin_layout Itemize
Socket.io: this is a critical point and we will follow table 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:socketio-test"

\end_inset

.
 As we said previously gun.js can be considered mono-thread, so we can test
 it with just one CPU.
\end_layout

\begin_layout Standard
Of course we have to test all the combinations: so we have 8 tests to do.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:postgresql-test"

\end_inset

postgreSQL (traditional approach) test environments
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features booktabs="true" tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
NÂ°
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
RAM [GB]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
NÂ° CPU
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:socketio-test"

\end_inset

socket.io (traditional approach) test environments
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="3">
<features booktabs="true" tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
NÂ°
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
RAM [GB]
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
NÂ° CPU
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "subsec:Custom-framework"

\end_inset

Test Framework
\end_layout

\begin_layout Standard
Since the systems used are custom or are new there are no stable frameworks
 to test their performance.
 So we started taking the approach, from one used and customizable framework
 called 
\begin_inset Quotes fld
\end_inset

YCSB
\begin_inset Quotes frd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "YCSB"

\end_inset

, we realized our framework that tests only what we need and in the way
 we want.
 The framework with tests prepared (and related things like SQL tables)
 could be found on github 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/carduz/master-thesis-source/tree/master/tests
\end_layout

\end_inset


\end_layout

\end_inset

 with instructions on the readme.
\end_layout

\begin_layout Standard
But we tested only performances (throughput and latency).
 A further analysis should test the consistency of the distributed environment,
 to do that there are some tools like 
\begin_inset Quotes fld
\end_inset

jepsen
\begin_inset Quotes frd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "JepsenTool"

\end_inset

 (we have shortly analyzed it in appendix 
\series bold

\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Jepsen-framework"

\end_inset


\series default
).
\end_layout

\begin_layout Standard
The framework we realized is done in javascript, so it is easy to integrate
 it with other platforms.
 Since we know which are the measures that we need, we have just to implement
 generally:
\end_layout

\begin_layout Itemize
Generator of data, according to the data structure.
 It is shown in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Tests-to-do-test"

\end_inset

.
\end_layout

\begin_layout Itemize
Client, general client that allows to send data and to read local databases
 (or receive data).
 It is shown in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Adapters-for-systems-test"

\end_inset

.
\end_layout

\begin_layout Standard
What we need to test are write and read performances.
 In fact, as we said, we have different models of data, but we do not have
 complex operations so we have only basic writes and written replications
 of data.
\begin_inset Newline newline
\end_inset

Since our critical point is the replication, we have to test with more than
 one client.
 We can consider a write completed when it is replicated in all clients.
\end_layout

\begin_layout Standard
So we need at least one client to make writes and at least one to check
 replications (called reads).
 The number of clients (writer and reader) depends on the type of application,
 that we will see in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Tests-to-do-test"

\end_inset

.
\end_layout

\begin_layout Standard
As we will see in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Tests-to-do-test"

\end_inset

 we will emulate different situations where we have (for example) 1 writer
 and 100 reader clients.
 So an important information is the latency of the synchronization to all
 these clients.
 We call execution the write/read data according to the number of writers/reader
s specified in the model in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Tests-to-do-test"

\end_inset

.
\begin_inset Newline newline
\end_inset

So we measure the following things:
\end_layout

\begin_layout Itemize
For every execution: latency to synchronize all clients and throughput (request/
latency to synchronize everything).
\end_layout

\begin_layout Itemize
Mean (with variance) latency to get data by each client.
\end_layout

\begin_layout Itemize
Final throughput: total number of requests (reads and writes) per second.
\end_layout

\begin_layout Standard
So each test unit is composed by different clients as defined in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Tests-to-do-test"

\end_inset

, so we execute more than one unit in parallel.
\end_layout

\begin_layout Standard
To do that we have a test manager that checks everything and communicates
 with clients, in fact every client is implemented as another process.
\begin_inset Newline newline
\end_inset

The creation of a process and communication is managed by the framework
 in a transparent way.
 As we will see in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Adapters-for-systems-test"

\end_inset

, in order to map we need only client functions with the general client
 (it is done by the adapter).
\end_layout

\begin_layout Standard
The framework, since it is not a general framework, do not generate charts,
 it only generate raw data, charts can be generated using external and powerful
 instruments like sheet software.
\begin_inset Newline newline
\end_inset

Of course the test framework is executed on another virtual machine (with
 high resources) or in the host machine.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Tests-to-do-test"

\end_inset

Tests to do
\end_layout

\begin_layout Standard
In this section we will see what every class of the classes of applications
 (analyzed previously) needs.
 We will also define for each of them the number of clients to be used for
 tests, for some of them we can define more versions (e.g.
 test with 1 reader client then test 10 reader clients) to test scalability
 and adaptability of replication and concurrent writing.
\end_layout

\begin_layout Standard
Of course this is a simplified simulation of the behavior in these classes
 of applications.
\end_layout

\begin_layout Standard
All data shown (like the number of clients) are found after some minor empirical
 tests.
\end_layout

\begin_layout Standard
In some cases data structure needs some changes to be adapted to the model
 of the database used.
 There are minor changes (simplifications) that are not shown here, of course
 the code on github contains everything.
\end_layout

\begin_layout Standard
We should consider also the size of data, but after some experiments, we
 have seen that some systems do not support a big amount of data.
 So the test would be inconsistent.
 Of course we analyze the data volume adaptability, with data volume we
 mean the volume of the data in the database (not the size of the single
 field).
\end_layout

\begin_layout Subsection
Realtime chat
\end_layout

\begin_layout Paragraph
Clients
\end_layout

\begin_layout Standard
As we said previously, since it has a room based chat, we expect #reads
 >> #writes.
 This example is useful to test the performances of a lot of clients subscribed
 to a subscription.
 So a reasonable number of clients could be the one shown in 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Realtime-chat-clients"

\end_inset

.
 In that table is shown also the number of rooms.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Realtime-chat-clients"

\end_inset

Realtime chat clients
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features booktabs="true" tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
NÂ°
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
NÂ° Writer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
NÂ° Reader
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
NÂ° Room
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Data generation
\end_layout

\begin_layout Standard
After a trial data initialization (e.g.
 users creation or room creation), to do tests we have just to create messages.
 So our generator is simply a faker text generator, other things like the
 user can be static.
 As we will see in the next section, we have to manage the room where to
 write.
 
\end_layout

\begin_layout Paragraph
Writing
\end_layout

\begin_layout Standard
We want that a writer is subscribed only to one room.
\end_layout

\begin_layout Paragraph
Reading
\end_layout

\begin_layout Standard
We want that each read is subscribed to 2 rooms (if possible).
\end_layout

\begin_layout Subsection
Collaborative software
\end_layout

\begin_layout Paragraph
Clients
\end_layout

\begin_layout Standard
As we said previously, we expect #reads 
\begin_inset Formula $\simeq$
\end_inset

#writes.
 This example is useful to test the performances of concurrent writes.
 So a reasonable number of clients could be the one shown in 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Collaborative-software-clients"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Collaborative-software-clients"

\end_inset

Collaborative software clients
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features booktabs="true" tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
NÂ°
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
NÂ° Writer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
NÂ° Reader
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Data generation
\end_layout

\begin_layout Standard
After a trial data initialization (e.g.
 users creation), to do tests we have just to create changes.
 A change is a JSON object of the structure shown in 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Collaborative-sw-te"

\end_inset

.
 We can consider everything static except start and change that should be
 respectively faker number and text.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,commentstyle={\color{purple!60!black}},extendedchars=true,identifierstyle={\color{blue!50!black}},keywordstyle={\bfseries\color{green!50!black}},language=JavaScript,numbers=left,numberstyle={\footnotesize},showstringspaces=false,stringstyle={\color{orange!40!black}},tabsize=4,xleftmargin=2em"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Collaborative-sw-te"

\end_inset

Collaborative software change structure
\end_layout

\end_inset

{
\end_layout

\begin_layout Plain Layout

	"timestampt":1490506829,
\end_layout

\begin_layout Plain Layout

	"changeObject": {
\end_layout

\begin_layout Plain Layout

		"start": 20,
\end_layout

\begin_layout Plain Layout

		"change": "abcd"
\end_layout

\begin_layout Plain Layout

	},
\end_layout

\begin_layout Plain Layout

	"user":"user1"
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Writing
\end_layout

\begin_layout Standard
Here the writing is trivial, all clients write to history (list of changes).
\end_layout

\begin_layout Paragraph
Reading
\end_layout

\begin_layout Standard
Here the reading is trivial, all clients subscribe to history (list of changes).
\end_layout

\begin_layout Subsection
Social
\end_layout

\begin_layout Paragraph
Clients
\end_layout

\begin_layout Standard
As we said previously we expect #reads >> #writes.
 This example is useful to test the performances of a lot of clients subscribed
 to multiple subscriptions.
 So a reasonable number of clients could be the one shown in 
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Social-clients"

\end_inset

.
\begin_inset Newline newline
\end_inset

In a social for each person there are a lot of users that see the write:
 followers and sometimes also followers of their directly followers.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "tab:Social-clients"

\end_inset

Social clients
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="3">
<features booktabs="true" tabularvalignment="middle">
<column alignment="center" valignment="top" width="0pt">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
NÂ°
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
NÂ° Writer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
NÂ° Reader
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
100
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Data generation
\end_layout

\begin_layout Standard
After a trial data initialization (e.g.
 users creation), we have different things:
\end_layout

\begin_layout Itemize
Posts: we should generate fake texts (contents).
\end_layout

\begin_layout Itemize
Comments: we should link users to posts.
 Of course since there are no checks we can generate random ids (also non
 exiting ones) for references.
\end_layout

\begin_layout Itemize
Likes: we can see that they are like comments.
 So, to simplify, we can skip them.
\end_layout

\begin_layout Standard
We can say that there are more comments than posts, for simplicity we can
 send a post every 9 comments.
\end_layout

\begin_layout Standard
When we generate a post we have a new post that can have comments, and where
 users can subscribe.
 So we have a subscription to new posts and multiple subscriptions for comments,
 each for every post.
\end_layout

\begin_layout Paragraph
Writing
\end_layout

\begin_layout Standard
As said previously the creation of a post is done every 9 comments, it is
 done by all writers.
\end_layout

\begin_layout Standard
We want that for each post we have two writers that write comments (if possible).
 The writers can comment to all posts, also older ones.
\end_layout

\begin_layout Paragraph
Reading
\end_layout

\begin_layout Standard
All clients subscribe to posts, they read all the new posts.
\end_layout

\begin_layout Standard
A client is subscribed to half of the posts.
 Even if new posts are created the old subscriptions are not deleted.
 So the more time passes, the more subscriptions are created.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Adapters-for-systems-test"

\end_inset

Adapters for systems
\end_layout

\begin_layout Standard
The general client needs:
\end_layout

\begin_layout Itemize
Login method.
\end_layout

\begin_layout Itemize
Join method to subscribe to channel and to a table/document.
\end_layout

\begin_layout Itemize
Write command.
\end_layout

\begin_layout Itemize
Data callback, that is called when there are new data (of course new data
 are passed as argument).
\end_layout

\begin_layout Standard
We have already proved that systems can provide authentication.
 But since it is implemented in different ways it could add another variable
 factor to consider that can change the final results, so we will skip it
 since it is not our main target to test.
\end_layout

\begin_layout Standard
Now we will analyze quickly how to implement these for all the platforms.
\end_layout

\begin_layout Paragraph
CouchBase
\end_layout

\begin_layout Itemize
Subscription: we cannot manage channels, we can choose only to which document
 we subscribe.
 So we receive notifications for every change in documents where we are
 subscribed.

\series bold
 
\series default
We could use filters 
\begin_inset CommandInset citation
LatexCommand cite
key "CouchbaseFilters"

\end_inset

 as workaround to this problem, but they are not so efficient and they are
 not so easy to use in a real environment (due to permissions needed to
 create filters).
\end_layout

\begin_layout Itemize
Write command: it is a normal asynchronous call.
\end_layout

\begin_layout Itemize
Data callback: it returns new data from the local database.
\end_layout

\begin_layout Paragraph
PouchDB
\end_layout

\begin_layout Itemize
Subscription: we cannot manage channels, we can choose only to which document
 we subscribe.
 So we receive notifications for every change in documents where we are
 subscribed.
 We could use filters 
\begin_inset CommandInset citation
LatexCommand cite
key "PouchDBFilter"

\end_inset

 as workaround to this problem, but they are not so efficient and they are
 not so easy to use in a real environment (due to permissions needed to
 create filters).
\end_layout

\begin_layout Itemize
Write command: it is a normal asynchronous call.
\end_layout

\begin_layout Itemize
Data callback: it returns new data from the local database.
\end_layout

\begin_layout Paragraph
Gun.js
\end_layout

\begin_layout Itemize
Subscription: we can subscribe to any level of the JSON structure, so we
 do not have problems (only messages that we need are delivered).
\end_layout

\begin_layout Itemize
Write command: it is a normal asynchronous call.
\end_layout

\begin_layout Itemize
Data callback: it returns new data from the local database.
\end_layout

\begin_layout Paragraph
Traditional approach
\end_layout

\begin_layout Itemize
Subscription: we can create custom channels and join them using join, so
 only messages that we need are delivered.
\end_layout

\begin_layout Itemize
Write command: it is a normal asynchronous call.
\end_layout

\begin_layout Itemize
Data callback: it returns new data from the local database.
\end_layout

\end_body
\end_document
