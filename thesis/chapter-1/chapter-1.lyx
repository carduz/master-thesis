#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\options openright
\use_default_options false
\master ../thesis.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding T1
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Indice
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
Since we will cover only HTTP based application we will start analyzing
 the an HTTP application stack.
 Then we will see how to make it
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 and the limits that are the causes of creation of realtime databases.
 Finally we will analyze the realtime databases approach.
\begin_inset Newline newline
\end_inset

Of course the protocol is not the only element need to build a realtime
 application but it is a must, without a right protocol that allow us to
 receive messages from the server we are not able to build a real realtime
 application.
\end_layout

\begin_layout Standard
We will also analyze the database itself, because in traditional database
 there is no an event notification system: we have to check it every time
 or we have to create a trigger to do that as we will see in the next sections.
 Of course the realtime databases resolve this.
\end_layout

\begin_layout Section
Traditional HTTP Application Stack
\end_layout

\begin_layout Standard
There are a lot of ways to build an Application over HTTP, a web application,
 but all have common parts.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename web-stack.png
	width 90col%
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Modern-web-application"

\end_inset

Modern web application stack
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In all the classical HTTP applications we have:
\end_layout

\begin_layout Enumerate
the client request something to the HTTP server (application server)
\end_layout

\begin_layout Enumerate
the HTTP server (application server) request data to Database Server
\end_layout

\begin_layout Enumerate
the HTTP server (application server) send the data to the client
\end_layout

\begin_layout Standard
as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Modern-web-application"

\end_inset

.
\end_layout

\begin_layout Standard
We will see the evolution of the HTTP that allow to create a real realtime
 application.
 The core of the issue is the HTTP handshake, in fact we need to have asynchrono
us requests, i.e.
 the server should be able to send messages to client at any time.
\end_layout

\begin_layout Subsection
HTTP handshake
\end_layout

\begin_layout Subsubsection
HTTP 1.0
\end_layout

\begin_layout Standard
Original version of HTTP (HTTP 1.0) allowed just connections that must be
 closed immediately after the receiving of data
\begin_inset CommandInset citation
LatexCommand cite
key "HTTP1.0"

\end_inset

, as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:HTTP1.0-vs-HTTP1.1"

\end_inset

 (first image):
\end_layout

\begin_layout Enumerate
The client request something
\end_layout

\begin_layout Enumerate
The server reply
\end_layout

\begin_layout Enumerate
The connection is closed
\end_layout

\begin_layout Standard
In this version the only approaches available to build a realtime application
 are:
\end_layout

\begin_layout Itemize
Short polling: schedule new request every a fixed small amount of time to
 check if the data are changed
\end_layout

\begin_layout Itemize
Long polling: create a normal request to the server.
 But the server reply only when there are new data, then the client create
 a new request
\end_layout

\begin_layout Itemize
Event Stream: a long request without end, where the server continues to
 send data to the client, this approach is used in video/music streaming.
\end_layout

\begin_layout Standard
All approaches have a lot of issues that reduce the performances
\begin_inset CommandInset citation
LatexCommand cite
key "PollingStreamProblems"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename HTTP1.png
	width 70col%
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:HTTP1.0-vs-HTTP1.1"

\end_inset

HTTP1.0 vs HTTP1.1 (using
\begin_inset Quotes fld
\end_inset

keep-alive
\begin_inset Quotes frd
\end_inset

)
\begin_inset CommandInset citation
LatexCommand cite
key "HTTPPersistent"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:HTTP-1.1"

\end_inset

HTTP 1.1
\end_layout

\begin_layout Standard
It is a new version of HTTP that fixed some issues and improved some things,
 it enabled the
\begin_inset Quotes fld
\end_inset

keep-alive
\begin_inset Quotes frd
\end_inset

 option (this option was implemented unofficial by a lot of HTTP 1.0 clients)
\begin_inset CommandInset citation
LatexCommand cite
key "HTTP1.1"

\end_inset


\end_layout

\begin_layout Standard
The keep alive options allows to use a the same connection multiple times,
 i.e.
 after a server reply the client can send another message over the same
 connection as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:HTTP1.0-vs-HTTP1.1"

\end_inset

 (second image).
\begin_inset Newline newline
\end_inset

This was originally projected to request different files over the same connectio
n.
 But it allowed to do a lot of other things, as we will see in the section
\begin_inset CommandInset ref
LatexCommand ref
reference "1.1.2"

\end_inset

 it is the enabling technology for websocket.
\end_layout

\begin_layout Subsubsection
HTTP 2.0
\end_layout

\begin_layout Standard
It is the newest HTTP standard (2015), it introduced a lot of improvements.
 The most important are: the possibility fort the server to
\begin_inset Quotes fld
\end_inset

push
\begin_inset Quotes frd
\end_inset

 data, that the client has not request explicitly and the possibility to
 have multiple parallel requests over a single TCP connection as shown in
 figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:HTTP2-multiple-parallel"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "HTTP2.0"

\end_inset

.
 These features allow also to increase the energy efficiency
\begin_inset CommandInset citation
LatexCommand cite
key "HTTP2.0Energy"

\end_inset

.
\end_layout

\begin_layout Standard
But, since it is new, it is not supported in efficient way by a lot of browsers
\begin_inset CommandInset citation
LatexCommand cite
key "HTTP2.0Support"

\end_inset

 and by a lot of websites
\begin_inset CommandInset citation
LatexCommand cite
key "HTTP2.0WebSites"

\end_inset

.
 So at the moment other solutions are preferred (like websocket).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename HTTP2.png
	width 90col%
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:HTTP2-multiple-parallel"

\end_inset

HTTP2 multiple parallel requests
\begin_inset CommandInset citation
LatexCommand cite
key "HTTP2.0Multiplex"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "1.1.2"

\end_inset

WebSocket
\end_layout

\begin_layout Standard
It is a protocol built over
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:HTTP-1.1"

\end_inset

 that allows to create a sort of
\begin_inset Quotes fld
\end_inset

socket
\begin_inset Quotes frd
\end_inset

 where both the client and the server can send and receive messages in any
 time
\begin_inset CommandInset citation
LatexCommand cite
key "WebSocket"

\end_inset

.
 This is done using an HTTP connection with
\begin_inset Quotes fld
\end_inset

keep-alive
\begin_inset Quotes frd
\end_inset

 option.
\end_layout

\begin_layout Standard
So this protocol allows to create a real efficient realtime application,
 where the client receives immediately a notification from the server (for
 server events)
\begin_inset CommandInset citation
LatexCommand cite
key "WebSocketRealTime"

\end_inset

 as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Websocket-with-server"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename websocket.gif
	width 40col%
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Websocket-with-server"

\end_inset

Websocket with server events
\begin_inset CommandInset citation
LatexCommand cite
key "WebsocketImg"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Data retrieve
\end_layout

\begin_layout Standard
Relational databases are not developed to send notification, the basic idea
 is:
\begin_inset Quotes fld
\end_inset

when you want data you get them
\begin_inset Quotes frd
\end_inset

.
\begin_inset Newline newline
\end_inset

So in the traditional HTTP applications, a shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Modern-web-application"

\end_inset

 for each request the HTTP server checks the database server.
\end_layout

\begin_layout Standard
If we want to make this process
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 we have to solve two main issues:
\end_layout

\begin_layout Enumerate
How to have a notification of a change? considering also distributed system
 case.
 The trivial solution is the usage of a database
\begin_inset Quotes fld
\end_inset

trigger
\begin_inset Quotes frd
\end_inset


\end_layout

\begin_layout Enumerate
How to manage clients in efficient way that want to have information about
 changes of only somethings and not of everything? The solution is to use
 the
\begin_inset Quotes fld
\end_inset

Publish/Subscribe
\begin_inset Quotes frd
\end_inset

 pattern
\begin_inset CommandInset citation
LatexCommand cite
key "PubSubDB"

\end_inset


\end_layout

\begin_layout Subsubsection
Database trigger
\end_layout

\begin_layout Standard
A trigger is a small snippet of code that is executed for some events such
 as inserting of data into a row.
\end_layout

\begin_layout Subsubsection
Publish/Subscribe
\end_layout

\begin_layout Standard
In Publish/Subscribe pattern each client that is interested to some data/events
\begin_inset Quotes fld
\end_inset

subscribe
\begin_inset Quotes frd
\end_inset

 to these, while the server service
\begin_inset Quotes fld
\end_inset

publish
\begin_inset Quotes frd
\end_inset

 the data that will be sent to the clients without knowing which are the
 client
\begin_inset Quotes fld
\end_inset

subscribed
\begin_inset Quotes frd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "PubSub"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Realtime retrieve
\end_layout

\begin_layout Standard
Now we have all elements to create a real realtime application:
\end_layout

\begin_layout Itemize
Each client
\begin_inset Quotes fld
\end_inset

subscribes
\begin_inset Quotes frd
\end_inset

 to the data that it needs.
\end_layout

\begin_layout Itemize
A trigger on the server
\begin_inset Quotes fld
\end_inset

publish
\begin_inset Quotes frd
\end_inset

 the data when they are updated.
\end_layout

\begin_layout Itemize
The communication between the client and server is over a websocket channel,
 so immediately after the data are published the server send data on this
 channel.
\end_layout

\begin_layout Section
Realtime databases stack
\end_layout

\begin_layout Standard
As we seen in the previous section with a standard HTTP application stack
 we can create a real realtime application, so why a
\begin_inset Quotes fld
\end_inset

realtime databses
\begin_inset Quotes frd
\end_inset

 were born?
\begin_inset Newline newline
\end_inset

They were born to increaser the performance and allow to create a realtime
 application a easier way (without implementing in manual way the entire
 stack):
\end_layout

\begin_layout Itemize
They use an unstructured data model, like a NoSQL database explained in
 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Simple-JSON-example"

\end_inset

, with a lot of advantages:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
the database can be easily partitioned and distributed over different nodes
\end_layout

\begin_layout Itemize
the client can subscribe only to a small portion of the data
\series bold
TODO SEE NOSQL SECTION
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
aaANOTRHR CHAPTER?
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:NoSQL-databases"

\end_inset

NoSQL databases
\end_layout

\begin_layout Standard
A NoSQL database is unstructured database, it can support a subset of the
 SQL instructions (but it is not mandatory).
 They were born to create scalable databases for Big Data applications
\begin_inset CommandInset citation
LatexCommand cite
key "NoSQL"

\end_inset

.
\end_layout

\begin_layout Standard
They can be easily partitioned but to ensure this in efficient way they
 have to renounce to the Consistency or to the Availability as shown in
 the figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:-Database-triangle"

\end_inset

 (more details are explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Consistency,-Partition-tolerance"

\end_inset

), we will see more details on the chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:technologies"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename db-triangle.png
	width 80col%
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:-Database-triangle"

\end_inset

Database triangle
\begin_inset CommandInset citation
LatexCommand cite
key "DBTriangle"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The data are stored in JSON format or other unstructured formats, the advantages
 and structure of JSON is explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:JSON"

\end_inset

.
\begin_inset Newline newline
\end_inset

Data are organized in 
\begin_inset Quotes fld
\end_inset

documents
\begin_inset Quotes frd
\end_inset

 not tables.
 Each document is a something that can contains data in JSON format, file
 or other things.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:JSON"

\end_inset

JSON
\end_layout

\begin_layout Standard
JSON (JavaScript Object Notation) is an easy standard to store data 
\begin_inset CommandInset citation
LatexCommand cite
key "JSON"

\end_inset

, it is not so powerful like XML but it is simpler so the computation is
 faster 
\begin_inset CommandInset citation
LatexCommand cite
key "JSONvsXML"

\end_inset

.
 On listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Simple-JSON-example"

\end_inset

 there is a simple example of a JSON structure.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,commentstyle={\color{purple!60!black}},extendedchars=true,identifierstyle={\color{blue!50!black}},keywordstyle={\bfseries\color{green!50!black}},language=JavaScript,numbers=left,numberstyle={\footnotesize},showstringspaces=false,stringstyle={\color{orange!40!black}},tabsize=4,xleftmargin=2em"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Simple-JSON-example"

\end_inset

Simple JSON example
\end_layout

\end_inset

{
\end_layout

\begin_layout Plain Layout

	"Main Array":[
\end_layout

\begin_layout Plain Layout

		[
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				"title": "Element 11"
\end_layout

\begin_layout Plain Layout

			},
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				"title": "Element 12"
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		],
\end_layout

\begin_layout Plain Layout

		[
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				"title": "Element 21"
\end_layout

\begin_layout Plain Layout

			},
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				"title": "Element 22"
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		]
\end_layout

\begin_layout Plain Layout

	]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
On the JSON structure there can be simple types, array or objects, in the
 previous example (listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Simple-JSON-example"

\end_inset

) we have:
\end_layout

\begin_layout Itemize
main object
\end_layout

\begin_deeper
\begin_layout Itemize
an array (called 
\begin_inset Quotes fld
\end_inset

Main Array
\begin_inset Quotes frd
\end_inset

)
\end_layout

\begin_deeper
\begin_layout Itemize
two arrays
\end_layout

\begin_deeper
\begin_layout Itemize
two objects (with 
\begin_inset Quotes fld
\end_inset

title
\begin_inset Quotes frd
\end_inset

 property)
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
So in a NoSQL database a 
\begin_inset Quotes fld
\end_inset

document
\begin_inset Quotes frd
\end_inset

 is composed by a JSON data like that.
 This structure is very powerful structure that allows to store a lot of
 complex structure.
\end_layout

\begin_layout Standard
A simple example can be a system where we have some users, each of them
 with a complex structure, each user is stored as object in a main array.
\begin_inset Newline newline
\end_inset

We will see this case and other on the chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:class-of-applications"

\end_inset

.
\end_layout

\begin_layout Standard
It is easy to see how this structure can be useful to 
\begin_inset Quotes fld
\end_inset

subscribe
\begin_inset Quotes frd
\end_inset

 only to a portion of data.
 For example using a structure like the one used in listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Simple-JSON-example"

\end_inset

, we can subscribe to the second element of the main array (an inner array)
 then we receive notification when an object (or other inner elements also
 complex elements):
\end_layout

\begin_layout Itemize
is added
\end_layout

\begin_layout Itemize
is updated
\end_layout

\begin_layout Itemize
is removed
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Consistency,-Partition-tolerance"

\end_inset

Consistency, Partition tolerance, Availability
\end_layout

\begin_layout Standard
The figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:-Database-triangle"

\end_inset

 shows the CAP theorem applied to the databases, it says that in the distributed
 system only two of the following three properties can be guarantee 
\begin_inset CommandInset citation
LatexCommand cite
key "CAPNoSQL,CAP"

\end_inset

:
\end_layout

\begin_layout Itemize
Consistency: 
\end_layout

\begin_layout Itemize
Availability:
\end_layout

\begin_layout Itemize
Partition tolerance:
\end_layout

\begin_layout Standard

\series bold
TODO nosql and next chapter
\end_layout

\end_body
\end_document
