#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\options openright
\use_default_options false
\master ../thesis.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding T1
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Indice
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
Since we will cover only HTTP based application we will start analyzing
 the an HTTP application stack on 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Traditional-HTTP-Application"

\end_inset

.
 Then we will see how to make it 
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 and the limits that are the causes of creation of realtime databases.
 Finally we will analyze the realtime databases approach on 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Realtime-databases-stack"

\end_inset

.
\begin_inset Newline newline
\end_inset

Of course the protocol is not the only element need to build a realtime
 application but it is a must, without a right protocol that allow us to
 receive messages from the server we are not able to build a real realtime
 application.
\end_layout

\begin_layout Standard
We will also analyze the database itself, because in traditional database
 there is no an event notification system: we have to check it every time
 or we have to create a trigger to do that as we will see in the next sections.
 Of course the realtime databases resolve this.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Traditional-HTTP-Application"

\end_inset

Traditional HTTP Application Stack
\end_layout

\begin_layout Standard
There are a lot of ways to build an Application over HTTP, a web application,
 but all have common parts.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename web-stack.png
	width 90col%
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Modern-web-application"

\end_inset

Modern web application stack
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In all the classical HTTP applications we have:
\end_layout

\begin_layout Enumerate
the client request something to the HTTP server (application server)
\end_layout

\begin_layout Enumerate
the HTTP server (application server) request data to Database Server
\end_layout

\begin_layout Enumerate
the HTTP server (application server) send the data to the client
\end_layout

\begin_layout Standard
as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Modern-web-application"

\end_inset

.
\end_layout

\begin_layout Standard
We will see the evolution of the HTTP that allow to create a real realtime
 application.
 The core of the issue is the HTTP handshake, in fact we need to have asynchrono
us requests, i.e.
 the server should be able to send messages to client at any time.
\end_layout

\begin_layout Subsection
HTTP handshake
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:HTTP-1.0"

\end_inset

HTTP 1.0
\end_layout

\begin_layout Standard
Original version of HTTP (HTTP 1.0) allowed just connections that must be
 closed immediately after the receiving of data
\begin_inset CommandInset citation
LatexCommand cite
key "HTTP1.0"

\end_inset

, as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:HTTP1.0-vs-HTTP1.1"

\end_inset

 (first image):
\end_layout

\begin_layout Enumerate
The client request something
\end_layout

\begin_layout Enumerate
The server reply
\end_layout

\begin_layout Enumerate
The connection is closed
\end_layout

\begin_layout Standard
In this version the only approaches available to build a realtime application
 are:
\end_layout

\begin_layout Itemize
Short polling: schedule new request every a fixed small amount of time to
 check if the data are changed
\end_layout

\begin_layout Itemize
Long polling: create a normal request to the server.
 But the server reply only when there are new data, then the client create
 a new request
\end_layout

\begin_layout Itemize
Event Stream: a long request without end, where the server continues to
 send data to the client, this approach is used in video/music streaming.
\end_layout

\begin_layout Standard
All approaches have a lot of issues that reduce the performances
\begin_inset CommandInset citation
LatexCommand cite
key "PollingStreamProblems"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename HTTP1.png
	width 70col%
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:HTTP1.0-vs-HTTP1.1"

\end_inset

HTTP1.0 vs HTTP1.1 (using
\begin_inset Quotes fld
\end_inset

keep-alive
\begin_inset Quotes frd
\end_inset

)
\begin_inset CommandInset citation
LatexCommand cite
key "HTTPPersistent"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:HTTP-1.1"

\end_inset

HTTP 1.1
\end_layout

\begin_layout Standard
It is a new version of HTTP that fixed some issues and improved some things,
 it enabled the
\begin_inset Quotes fld
\end_inset

keep-alive
\begin_inset Quotes frd
\end_inset

 option (this option was implemented unofficial by a lot of HTTP 1.0 clients)
\begin_inset CommandInset citation
LatexCommand cite
key "HTTP1.1"

\end_inset


\end_layout

\begin_layout Standard
The keep alive options allows to use a the same connection multiple times,
 i.e.
 after a server reply the client can send another message over the same
 connection as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:HTTP1.0-vs-HTTP1.1"

\end_inset

 (second image).
\begin_inset Newline newline
\end_inset

This was originally projected to request different files over the same connectio
n.
 But it allowed to do a lot of other things, as we will see in the section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:WebSocket"

\end_inset

 it is the enabling technology for websocket.
\end_layout

\begin_layout Subsubsection
HTTP 2.0
\end_layout

\begin_layout Standard
It is the newest HTTP standard (2015), it introduced a lot of improvements.
 The most important are: the possibility fort the server to
\begin_inset Quotes fld
\end_inset

push
\begin_inset Quotes frd
\end_inset

 data, that the client has not request explicitly and the possibility to
 have multiple parallel requests over a single TCP connection as shown in
 figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:HTTP2-multiple-parallel"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "HTTP2.0"

\end_inset

.
 These features allow also to increase the energy efficiency
\begin_inset CommandInset citation
LatexCommand cite
key "HTTP2.0Energy"

\end_inset

.
\end_layout

\begin_layout Standard
But, since it is new, it is not supported in efficient way by a lot of browsers
\begin_inset CommandInset citation
LatexCommand cite
key "HTTP2.0Support"

\end_inset

 and by a lot of websites
\begin_inset CommandInset citation
LatexCommand cite
key "HTTP2.0WebSites"

\end_inset

.
 So at the moment other solutions are preferred (like websocket).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename HTTP2.png
	width 90col%
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:HTTP2-multiple-parallel"

\end_inset

HTTP2 multiple parallel requests
\begin_inset CommandInset citation
LatexCommand cite
key "HTTP2.0Multiplex"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:WebSocket"

\end_inset

WebSocket
\end_layout

\begin_layout Standard
It is a protocol built over 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:HTTP-1.1"

\end_inset

 that allows to create a sort of 
\begin_inset Quotes fld
\end_inset

socket
\begin_inset Quotes frd
\end_inset

 where both the client and the server can send and receive messages in any
 time
\begin_inset CommandInset citation
LatexCommand cite
key "WebSocket"

\end_inset

.
 This is done using an HTTP connection with
\begin_inset Quotes fld
\end_inset

keep-alive
\begin_inset Quotes frd
\end_inset

 option.
\end_layout

\begin_layout Standard
So this protocol allows to create a real efficient realtime application,
 where the client receives immediately a notification from the server (for
 server events)
\begin_inset CommandInset citation
LatexCommand cite
key "WebSocketRealTime"

\end_inset

 as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Websocket-with-server"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename websocket.gif
	width 40col%
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Websocket-with-server"

\end_inset

Websocket with server events
\begin_inset CommandInset citation
LatexCommand cite
key "WebsocketImg"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:RESTful"

\end_inset

RESTful
\end_layout

\begin_layout Standard
As shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Modern-web-application"

\end_inset

 we can use 
\begin_inset Quotes fld
\end_inset

RESTful call
\begin_inset Quotes frd
\end_inset

 to retrieve data, RESTful is a sort of protocol to exchange messages between
 client and server over HTTP (it uses standard HTTP methods) 
\begin_inset CommandInset citation
LatexCommand cite
key "RESTful"

\end_inset

.
\begin_inset Newline newline
\end_inset

It is simple protocol the uses the the HTTP verbs, for example to create
 a new data a 
\begin_inset Quotes fld
\end_inset

post
\begin_inset Quotes frd
\end_inset

 call must be done, while to update a data a 
\begin_inset Quotes fld
\end_inset

put
\begin_inset Quotes frd
\end_inset

 call must be done, this is the CRUD approach 
\begin_inset CommandInset citation
LatexCommand cite
key "CRUD"

\end_inset

.
 The idea is to do simple actions on resources that returns immediately
 an answer (like GET call) or execute immediatelly an action (like POST
 call)
\begin_inset Newline newline
\end_inset

There is another protocol older than RESTful, still used: SOAP, it is very
 powerful but as we will see to manage resource RESTfull is better 
\begin_inset CommandInset citation
LatexCommand cite
key "RESTSOAP,SOAPvsREST"

\end_inset

.
\end_layout

\begin_layout Standard
RESTfull is designed to work with resources, in fact each resource is identified
 by an unique URI and there are standard actions (HTTP verbs) for each resources.
 For example we can have:
\end_layout

\begin_layout Itemize
Customers identified by 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

htttp://example.com/customers
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Customer details with an unique ID (for example id = 10) identified by 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

htttp://example.com/customers/10
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Contacts of a customer identified by 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

htttp://example.com/customers/10/contacts
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
It is easy to understand how this can be useful to surf cross a JSON structure
 (the URI can be the refer to a specific level of the JSON structure) that
 we will see on 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:JSON"

\end_inset

.
 In fact, often, RESTfull service retrieve JSON data, but they can also
 retrieve XML.
\end_layout

\begin_layout Standard
We will see real examples on 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:RESTful-Approach"

\end_inset

.
\end_layout

\begin_layout Subsection
Data retrieve
\end_layout

\begin_layout Standard
Relational databases are not developed to send notification, the basic idea
 is:
\begin_inset Quotes fld
\end_inset

when you want data you get them
\begin_inset Quotes frd
\end_inset

.
\begin_inset Newline newline
\end_inset

So in the traditional HTTP applications, a shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Modern-web-application"

\end_inset

 for each request the HTTP server checks the database server.
\end_layout

\begin_layout Standard
If we want to make this process
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 we have to solve two main issues:
\end_layout

\begin_layout Enumerate
How to have a notification of a change? considering also distributed system
 case.
 The trivial solution is the usage of a database 
\begin_inset Quotes fld
\end_inset

trigger
\begin_inset Quotes frd
\end_inset

 as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Database-trigger"

\end_inset


\end_layout

\begin_layout Enumerate
How to manage clients in efficient way that want to have information about
 changes of only somethings and not of everything? The solution is to use
 the
\begin_inset Quotes fld
\end_inset

Publish/Subscribe
\begin_inset Quotes frd
\end_inset

 pattern
\begin_inset CommandInset citation
LatexCommand cite
key "PubSubDB"

\end_inset

 as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Publish/Subscribe"

\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Database-trigger"

\end_inset

Database trigger
\end_layout

\begin_layout Standard
A trigger is a small snippet of code that is executed for some events such
 as inserting of data into a row.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Publish/Subscribe"

\end_inset

Publish/Subscribe
\end_layout

\begin_layout Standard
In Publish/Subscribe pattern each client that is interested to some data/events
 
\begin_inset Quotes fld
\end_inset

subscribe
\begin_inset Quotes frd
\end_inset

 to these, while the server service 
\begin_inset Quotes fld
\end_inset

publish
\begin_inset Quotes frd
\end_inset

 the data that will be sent to the clients without knowing which are the
 client
\begin_inset Quotes fld
\end_inset

subscribed
\begin_inset Quotes frd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "PubSub"

\end_inset

.
 Of course Publish/Subscribe is not compatible with RESTful calls since
 in the RESTfull approach the data must be returned immediately when a request
 is done as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:RESTful"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Realtime retrieve
\end_layout

\begin_layout Standard
Now we have all elements to create a real realtime application:
\end_layout

\begin_layout Itemize
Each client 
\begin_inset Quotes fld
\end_inset

subscribes
\begin_inset Quotes frd
\end_inset

 to the data that it needs.
\end_layout

\begin_layout Itemize
A trigger on the server 
\begin_inset Quotes fld
\end_inset

publish
\begin_inset Quotes frd
\end_inset

 the data when they are updated.
\end_layout

\begin_layout Itemize
The communication between the client and server is over a websocket channel,
 so immediately after the data are published the server send data on this
 channel.
 As said in in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Publish/Subscribe"

\end_inset

 RESTful cannot be used.
\end_layout

\begin_layout Standard
Of course there are still issues related to distribution and partitioning
 of the infrastructure as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Partitioning-and-Distribution"

\end_inset

.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Realtime-databases-stack"

\end_inset

Realtime databases stack
\end_layout

\begin_layout Standard
As we seen in the previous section with a standard HTTP application stack
 we can create a real realtime application, so why a
\begin_inset Quotes fld
\end_inset

realtime databses
\begin_inset Quotes frd
\end_inset

 were born?
\begin_inset Newline newline
\end_inset

They were born to increaser the performance and allow to create a realtime
 application a easier way (without implementing in manual way the entire
 stack), we can see analogous tiers shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Modern-web-application"

\end_inset

:
\end_layout

\begin_layout Itemize
DB: they use an unstructured data model, like a NoSQL database explained
 in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:NoSQL-databases"

\end_inset

, with a lot of advantages:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
the database can be easily partitioned and distributed over different nodes,
 an important property as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Partitioning-and-Distribution"

\end_inset


\end_layout

\begin_layout Itemize
the client can 
\begin_inset Quotes fld
\end_inset

subscribe
\begin_inset Quotes frd
\end_inset

 only to a small portion of the data as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:JSON"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Application: they create a distributed Publish/Subscribe server, the distributio
n is not an easy task as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Distribution"

\end_inset


\end_layout

\begin_layout Itemize
Client: They provide client libraries to use Publish/Subscribe in efficient
 and transparent way as we will see in th chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:technologies"

\end_inset


\end_layout

\begin_layout Standard
Everything can be implemented in a serverless approach as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Serverless"

\end_inset

, an efficient approach that can also give a lot of economic advantages
 in different situations.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:NoSQL-databases"

\end_inset

NoSQL databases
\end_layout

\begin_layout Standard
A NoSQL database is unstructured database, it can support a subset of the
 SQL instructions (but it is not mandatory).
 They were born to create scalable databases for Big Data applications,
 in fact they can have 
\begin_inset Quotes fld
\end_inset

multiple masters
\begin_inset Quotes frd
\end_inset

 support (the ability to write data using different master nodes) 
\begin_inset CommandInset citation
LatexCommand cite
key "NoSQL"

\end_inset

.
\end_layout

\begin_layout Standard
They can be easily partitioned but to ensure this in efficient way they
 have to renounce to the Consistency or to the Availability as shown in
 the figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:-Database-triangle"

\end_inset

 (more details are explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Consistency,-Partition-tolerance"

\end_inset

), we will see more details on the chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:technologies"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename db-triangle.png
	width 80col%
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:-Database-triangle"

\end_inset

Database triangle
\begin_inset CommandInset citation
LatexCommand cite
key "DBTriangle"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The data are stored in JSON format or other unstructured formats, the advantages
 and structure of JSON is explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:JSON"

\end_inset

.
\begin_inset Newline newline
\end_inset

Data are organized in 
\begin_inset Quotes fld
\end_inset

documents
\begin_inset Quotes frd
\end_inset

 not tables.
 Each document is a something that can contains data in JSON format, file
 or other things.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:JSON"

\end_inset

JSON
\end_layout

\begin_layout Standard
JSON (JavaScript Object Notation) is an easy standard to store data 
\begin_inset CommandInset citation
LatexCommand cite
key "JSON"

\end_inset

, it is not so powerful like XML but it is simpler so the computation is
 faster 
\begin_inset CommandInset citation
LatexCommand cite
key "JSONvsXML"

\end_inset

.
 On listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Simple-JSON-example"

\end_inset

 there is a simple example of a JSON structure.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,commentstyle={\color{purple!60!black}},extendedchars=true,identifierstyle={\color{blue!50!black}},keywordstyle={\bfseries\color{green!50!black}},language=JavaScript,numbers=left,numberstyle={\footnotesize},showstringspaces=false,stringstyle={\color{orange!40!black}},tabsize=4,xleftmargin=2em"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Simple-JSON-example"

\end_inset

Simple JSON example
\end_layout

\end_inset

{
\end_layout

\begin_layout Plain Layout

	"main_array":[
\end_layout

\begin_layout Plain Layout

		[
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				"title": "Element 11"
\end_layout

\begin_layout Plain Layout

			},
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				"title": "Element 12"
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		],
\end_layout

\begin_layout Plain Layout

		[
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				"title": "Element 21"
\end_layout

\begin_layout Plain Layout

			},
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				"title": "Element 22"
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		]
\end_layout

\begin_layout Plain Layout

	]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
On the JSON structure there can be simple types, array or objects, in the
 previous example (listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Simple-JSON-example"

\end_inset

) we have:
\end_layout

\begin_layout Itemize
main object
\end_layout

\begin_deeper
\begin_layout Itemize
an array (called 
\begin_inset Quotes fld
\end_inset

main_array
\begin_inset Quotes frd
\end_inset

)
\end_layout

\begin_deeper
\begin_layout Itemize
two arrays
\end_layout

\begin_deeper
\begin_layout Itemize
two objects (with 
\begin_inset Quotes fld
\end_inset

title
\begin_inset Quotes frd
\end_inset

 property)
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
So in a NoSQL database a 
\begin_inset Quotes fld
\end_inset

document
\begin_inset Quotes frd
\end_inset

 is composed by a JSON data like that.
 This structure is very powerful structure that allows to store a lot of
 complex structure.
\end_layout

\begin_layout Standard
A simple example can be a system where we have some users, each of them
 with a complex structure, each user is stored as object in a main array.
\begin_inset Newline newline
\end_inset

We will see this case and other on the chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:class-of-applications"

\end_inset

.
\end_layout

\begin_layout Standard
As introduced in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:RESTful"

\end_inset

 the RESTful is a good protocol for JSON and, in general, NoSQL databases
 
\begin_inset CommandInset citation
LatexCommand cite
key "RESTNOSQL"

\end_inset

.
\end_layout

\begin_layout Standard
It is easy to see how this structure can be useful to 
\begin_inset Quotes fld
\end_inset

subscribe
\begin_inset Quotes frd
\end_inset

 only to a portion of data, to a 
\begin_inset Quotes fld
\end_inset

path
\begin_inset Quotes frd
\end_inset

.
 For example using a structure like the one used in listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Simple-JSON-example"

\end_inset

, we can subscribe to the second element of the main array (an inner array)
 then we receive notification when an object (or other inner elements also
 complex elements) is:
\end_layout

\begin_layout Itemize
added
\end_layout

\begin_layout Itemize
removed
\end_layout

\begin_layout Itemize
updated
\end_layout

\begin_layout Standard
We see better what means subscribe to a specif 
\begin_inset Quotes fld
\end_inset

path
\begin_inset Quotes frd
\end_inset

 of the JSON structure in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Client-best-practices"

\end_inset

.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Consistency,-Partition-tolerance"

\end_inset

Consistency, Partition tolerance, Availability
\end_layout

\begin_layout Standard
The figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:-Database-triangle"

\end_inset

 shows the CAP theorem applied to the databases, it says that in the distributed
 system only two of the following three properties can be guarantee 
\begin_inset CommandInset citation
LatexCommand cite
key "CAPNoSQL,CAP"

\end_inset

:
\end_layout

\begin_layout Itemize
Consistency: all nodes receive the most recent data (write)
\end_layout

\begin_layout Itemize
Availability: all requests receive a response with data (this doesn't ensure
 that data are the newest)
\end_layout

\begin_layout Itemize
Partition tolerance: the system work properly even if the data are partitioned
 among nodes, also if some of them are unreachable
\end_layout

\begin_layout Standard
In the distributed systems the main issue is the synchronization among nodes:
 there is no a common clock, so it is not so easy determinate the order
 of commits.
\end_layout

\begin_layout Standard
ACID (Atomicity, Consistency, Isolation, Durability) databases (traditional
 relational databases) choose Availability and Consistency 
\begin_inset CommandInset citation
LatexCommand cite
key "CAPNoSQL"

\end_inset

.
\end_layout

\begin_layout Standard
Instead NoSQL choose Availability and Partition tolerance or Consistency
 and Partition tolerance 
\begin_inset CommandInset citation
LatexCommand cite
key "CAPNoSQL"

\end_inset

.
 In the chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:technologies"

\end_inset

 we will see NoSQL databases of both types.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Partitioning-and-Distribution"

\end_inset

Partitioning and Distribution
\end_layout

\begin_layout Standard
There are some systems that use booth the ideas.
 For example HDFS (a distributed file system) that replicates the data among
 nodes and partitions the data among nodes 
\begin_inset CommandInset citation
LatexCommand cite
key "HDFS"

\end_inset

.
 So a chunk of data is replicated some times but it is not present in all
 nodes.
\end_layout

\begin_layout Subsubsection
Partitioning
\end_layout

\begin_layout Standard
Partition data among different nodes means split the data into chunks according
 to some rules defined and put different chunks into different nodes 
\begin_inset CommandInset citation
LatexCommand cite
key "CAPNoSQL,NoSQL"

\end_inset

.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Distribution"

\end_inset

Distribution
\end_layout

\begin_layout Standard
The distribution is the replication of the infrastructure among different
 nodes, each node do the same thing.
 It is not a so easy concept, in fact there is the synchronization problem
 (formally know as consistency) 
\begin_inset CommandInset citation
LatexCommand cite
key "CAP"

\end_inset

 for example in the following scenarios:
\end_layout

\begin_layout Itemize
Commit data in a distributed database: the problem is find the correct commits
 order since there is no a common clock
\end_layout

\begin_layout Itemize
Publish/Subscribe: in a Publish/Subscribe application distributed among
 different nodes, how a published data in a node is sent to all subscribed
 clients also the ones subscribed on other nodes?
\end_layout

\begin_layout Standard
As said previously in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:NoSQL-databases"

\end_inset

 the NoSQL database are distributed.
 Also the master node can be distributed, so the client can commit on different
 nodes.
 This increase the performance, since there are no saturation issues of
 the server or of the locks need to write data (commit) 
\begin_inset CommandInset citation
LatexCommand cite
key "NoSQL"

\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sec:Serverless"

\end_inset

Serverless
\end_layout

\begin_layout Standard
A serverless is a cloud computing architecture, where the developer has
 not to think about the infrastructure.
 It is something at the middle between 
\begin_inset Quotes fld
\end_inset

Platform as a Service
\begin_inset Quotes frd
\end_inset

 and 
\begin_inset Quotes fld
\end_inset

Software as a Service
\begin_inset Quotes frd
\end_inset

, for that reason it is also know as 
\begin_inset Quotes fld
\end_inset

Function as a Service
\begin_inset Quotes frd
\end_inset

.
\begin_inset Newline newline
\end_inset

The serverless idea is a general idea that can be implemented for different
 things, a classic implementation is for file systems 
\begin_inset CommandInset citation
LatexCommand cite
key "ServerlessFilesystem"

\end_inset

.
\end_layout

\begin_layout Standard
In serverless architecture the developer has to think only to develop the
 application without thinking how to scale the infrastructure, how to store
 data in secure way and so on.
 In serveless architecture the developer has not to develop a real server,
 the server is already set, he has only to configure it and eventually develop
 some small extension (in database case the extension can be simply the
 triggers).
\begin_inset Newline newline
\end_inset

Like 
\begin_inset Quotes fld
\end_inset

Function as a service
\begin_inset Quotes frd
\end_inset

 suggest we can have also system where we have to develop just a piece of
 code, a function, that is executed in a 
\begin_inset Quotes fld
\end_inset

unknown
\begin_inset Quotes frd
\end_inset

 infrastructure, where we have not to think about scalability, we pay just
 for usage.
 For example we pay the number of execution of that function, this is the
 way used by 
\begin_inset Quotes fld
\end_inset

Amazon AWS
\begin_inset Quotes frd
\end_inset

 implementation: 
\begin_inset Quotes fld
\end_inset

AWS Lambda
\begin_inset Quotes frd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "AWSLambda,AWSLambdaPricing"

\end_inset

.
 This is a big advantage for user, because there is an instant scalability
 that there is not on 
\begin_inset Quotes fld
\end_inset

Platform as a Service
\begin_inset Quotes frd
\end_inset

 as we will see on 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Platform-as-a"

\end_inset

.
\end_layout

\begin_layout Standard
As we will see on 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Main-Realtime-Databases"

\end_inset

 this kind of architecture is entirely developed on cloud architecture and
 partially developed on Open Source architectures, in open source architecture
 we have the facility to configure and develop the server but we don't have
 an easy scalability like the cloud systems.
\end_layout

\begin_layout Standard
After we will see 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Software-as-a"

\end_inset

 we will know how that the difference among these three kind of architecture
 is minimal and that often there is overlapping among the architectures.
\begin_inset Newline newline
\end_inset

An example of overlapping is 
\begin_inset Quotes fld
\end_inset

Salesforce.com
\begin_inset Quotes frd
\end_inset

, a CRM (customer relationship management) service born like a 
\begin_inset Quotes fld
\end_inset

Software as a Service
\begin_inset Quotes frd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "SAAS"

\end_inset

.
 But it became a sort of Serverless architecture to build business applications,
 it has also bought 
\begin_inset Quotes fld
\end_inset

Heroku
\begin_inset Quotes frd
\end_inset

 a 
\begin_inset Quotes fld
\end_inset

Platform as a Service
\begin_inset Quotes frd
\end_inset

 company.
 However, even if now it is like a serverless service, the price system
 has remained the same as that of 
\begin_inset Quotes fld
\end_inset

Software as a Service
\begin_inset Quotes frd
\end_inset

 system, where you don't pay the usage, you pay for accounts and each account
 has some limits 
\begin_inset CommandInset citation
LatexCommand cite
key "SalesforcePricing"

\end_inset

.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Platform-as-a"

\end_inset

Platform as a Service
\end_layout

\begin_layout Standard
\begin_inset Quotes fld
\end_inset

Platform as a Service
\begin_inset Quotes frd
\end_inset

 is cloud computing architecture where the developer have not to think about
 infrastructure, he chooses the platform where to develop that is automatically
 configured and ready to use 
\begin_inset CommandInset citation
LatexCommand cite
key "PAAS"

\end_inset

.
 In this kind of architecture the developer has to choose how to scale (it
 can be an automatic process) but in an easy way, often he has only to choose
 the number of nodes.
\end_layout

\begin_layout Standard
One of the most known 
\begin_inset Quotes fld
\end_inset

Platform as a Service
\begin_inset Quotes frd
\end_inset

 service is 
\begin_inset Quotes fld
\end_inset

Heroku
\begin_inset Quotes frd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Heroku"

\end_inset

, comparing the price system of 
\begin_inset Quotes fld
\end_inset

Heroku
\begin_inset Quotes frd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "HerokuPricing"

\end_inset

 with the price system of 
\begin_inset Quotes fld
\end_inset

AWS Lambda
\begin_inset Quotes frd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "AWSLambdaPricing"

\end_inset

 we can see that in 
\begin_inset Quotes fld
\end_inset

Heroku
\begin_inset Quotes frd
\end_inset

 we pay for number of nodes per seconds, while in 
\begin_inset Quotes fld
\end_inset

AWS Lambda
\begin_inset Quotes frd
\end_inset

 we pay just for execution time.
 In 
\begin_inset Quotes fld
\end_inset

AWS Lambda
\begin_inset Quotes frd
\end_inset

 we have not to do anything to execute just one 
\begin_inset Quotes fld
\end_inset

function
\begin_inset Quotes frd
\end_inset

 per second or thousands per second, while on 
\begin_inset Quotes fld
\end_inset

Heroku
\begin_inset Quotes frd
\end_inset

 we have to set the right number of nodes or set a correct strategy to dynamical
ly create/remove nodes.
 So the serverless approach can reach the maximum grade of sharing resources
 in cloud computing.
\end_layout

\begin_layout Standard
For what concern the concept of platform ready to use to develop the serverless
 architecture is similar to 
\begin_inset Quotes fld
\end_inset

Platform as a Service
\begin_inset Quotes frd
\end_inset

 but it is different for other things like scalability as we have seen with
 
\begin_inset Quotes fld
\end_inset

AWS Lambda
\begin_inset Quotes frd
\end_inset

 example.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Software-as-a"

\end_inset

Software as a Service
\end_layout

\begin_layout Standard
\begin_inset Quotes fld
\end_inset

Software as a service
\begin_inset Quotes frd
\end_inset

 is a cloud computing architecture where there is no need or possibility
 to develop anything 
\begin_inset CommandInset citation
LatexCommand cite
key "SAAS"

\end_inset

.
 One classic example is a webmail service, that can be configured for a
 private company.
\end_layout

\begin_layout Standard
One of the most known 
\begin_inset Quotes fld
\end_inset

Software as a service
\begin_inset Quotes frd
\end_inset

 service is 
\begin_inset Quotes fld
\end_inset

Google apps for work
\begin_inset Quotes frd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "GoogleWork"

\end_inset

, a service where the employees of a company have access to company mail,
 company docs, company cloud storage and so on; everything is done only
 by configure a system without develop anything.
 The price system of 
\begin_inset Quotes fld
\end_inset

Google apps for work
\begin_inset Quotes frd
\end_inset

 is system where the company has to pay for the number of user not for the
 usage 
\begin_inset CommandInset citation
LatexCommand cite
key "GoogleWorkPricing"

\end_inset

 an approach completely different from other cloud system, but it is a good
 approach for company because in that way they are able to predict the cost
 in reliable way.
\end_layout

\begin_layout Standard
The serverless approach is very similar to 
\begin_inset Quotes fld
\end_inset

Software as a service
\begin_inset Quotes frd
\end_inset

 since the developer has not to think about the infrastructure or how to
 build a reliable server, but instead of the 
\begin_inset Quotes fld
\end_inset

Software as a service
\begin_inset Quotes frd
\end_inset

 in the serverless architecture the developer can develop something, not
 only configure.
\end_layout

\end_body
\end_document
