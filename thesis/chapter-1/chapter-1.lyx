#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\options openright
\use_default_options false
\master ../thesis.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding T1
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Indice
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
Since we will cover only HTTP based application we will start analyzing
 an HTTP application stack on 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Traditional-HTTP-Application"

\end_inset

.
 Of course the protocol is not the only element needed to build an application
 that receives realtime notifications of changes but it is a must.
 Without a right protocol, that allows us to receive messages from the server,
 we are not able to build an efficient application that receives 
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 notifications of changes.
\end_layout

\begin_layout Standard
Then we will see basic concept and issues of data in a distributed system
 in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Data-Management"

\end_inset

.
 We will also analyze the database itself, because in traditional databases
 there is no native event notification system: we have to check it every
 time (polling) or we have to create a trigger to do that as we will see
 in the next sections.
\begin_inset Newline newline
\end_inset

We will analyze also the how to send realtime notifications of changes and
 the limits that are the causes of the creation of NoSQL 
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 databases.
\end_layout

\begin_layout Standard
Finally we will quickly see concepts beyond cloud computing from user point
 of view in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Serverless"

\end_inset

, since a lot of systems that we will analyze in the next chapters are in
 cloud.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Traditional-HTTP-Application"

\end_inset

HTTP
\end_layout

\begin_layout Standard
There are a lot of ways to build an Application over HTTP, a web application,
 but all have common parts.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename web-stack.png
	width 90col%
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Modern-web-application"

\end_inset

Modern web application stack
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In all the classical HTTP applications we have:
\end_layout

\begin_layout Enumerate
the client requests something to the HTTP server (application server)
\end_layout

\begin_layout Enumerate
the HTTP server (application server) requests data to Database Server
\end_layout

\begin_layout Enumerate
the HTTP server (application server) sends the data to the client
\end_layout

\begin_layout Standard
as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Modern-web-application"

\end_inset

.
\end_layout

\begin_layout Standard
We will see the evolution of the HTTP that allows to send realtime notifications.
 The core of the issue is the HTTP handshake analyzed in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:HTTP-handshake"

\end_inset

, in fact we need to have asynchronous requests, i.e.
 the server should be able to send messages to the client at any time 
\begin_inset CommandInset citation
LatexCommand cite
key "SyncAsync"

\end_inset

.
\end_layout

\begin_layout Standard
We will also see standard related to HTTP: websocket in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:WebSocket"

\end_inset

 and RESTful in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:RESTful"

\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:HTTP-handshake"

\end_inset

HTTP handshake
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:HTTP-1.0"

\end_inset

HTTP 1.0
\end_layout

\begin_layout Standard
The original version of HTTP (HTTP 1.0) allowed just connections that must
 be closed immediately after the receiving of data 
\begin_inset CommandInset citation
LatexCommand cite
key "HTTP1.0"

\end_inset

, as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:HTTP1.0-vs-HTTP1.1"

\end_inset

 (first image):
\end_layout

\begin_layout Enumerate
The client requests something
\end_layout

\begin_layout Enumerate
The server replies
\end_layout

\begin_layout Enumerate
The connection is closed
\end_layout

\begin_layout Standard
In this version the only approaches available to make realtime notifications
 are:
\end_layout

\begin_layout Itemize
Short polling: schedule new request every fixed small amount of time to
 check if the data are changed
\end_layout

\begin_layout Itemize
Long polling: create a normal request to the server.
 But the server replies only when there are new data, then the client creates
 a new request
\end_layout

\begin_layout Itemize
Event Stream: a long request without end, where the server continues to
 send data to the client, this approach is used in video/music streaming.
\end_layout

\begin_layout Standard
All approaches have a lot of issues that reduce the performances
\begin_inset CommandInset citation
LatexCommand cite
key "PollingStreamProblems"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename HTTP1.png
	width 70col%
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:HTTP1.0-vs-HTTP1.1"

\end_inset

HTTP1.0 vs HTTP1.1 (using
\begin_inset Quotes fld
\end_inset

keep-alive
\begin_inset Quotes frd
\end_inset

)
\begin_inset CommandInset citation
LatexCommand cite
key "HTTPPersistent"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:HTTP-1.1"

\end_inset

HTTP 1.1
\end_layout

\begin_layout Standard
It is a new version of HTTP that fixed some issues and improved some things,
 it enabled the 
\begin_inset Quotes fld
\end_inset

keep-alive
\begin_inset Quotes frd
\end_inset

 option (this option was implemented unofficially by a lot of HTTP 1.0 clients)
\begin_inset CommandInset citation
LatexCommand cite
key "HTTP1.1"

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Quotes fld
\end_inset

keep-alive
\begin_inset Quotes frd
\end_inset

 option allows to use the same connection multiple times, i.e.
 after a server replies the client can send another message over the same
 connection as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:HTTP1.0-vs-HTTP1.1"

\end_inset

 (second image).
\begin_inset Newline newline
\end_inset

This was originally projected to request different files over the same connectio
n.
 But it allowed to do a lot of other things, as we will see in the section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:WebSocket"

\end_inset

 it is the enabling technology for websocket.
\end_layout

\begin_layout Subsubsection
HTTP 2.0
\end_layout

\begin_layout Standard
It is the newest HTTP standard (2015), it introduced a lot of improvements.
 The most important are: the possibility for the server to 
\begin_inset Quotes fld
\end_inset

push
\begin_inset Quotes frd
\end_inset

 data, that the client has not requested explicitly and the possibility
 to have multiple parallel requests over a single TCP connection as shown
 in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:HTTP2-multiple-parallel"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "HTTP2.0"

\end_inset

.
 These features allow also to increase the energy efficiency
\begin_inset CommandInset citation
LatexCommand cite
key "HTTP2.0Energy"

\end_inset

.
\end_layout

\begin_layout Standard
But, since it is new, it is not supported in an efficient way by a lot of
 browsers
\begin_inset CommandInset citation
LatexCommand cite
key "HTTP2.0Support"

\end_inset

 and by a lot of websites
\begin_inset CommandInset citation
LatexCommand cite
key "HTTP2.0WebSites"

\end_inset

.
 So at the moment other solutions are preferred (like websocket).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename HTTP2.png
	width 90col%
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:HTTP2-multiple-parallel"

\end_inset

HTTP2 multiple parallel requests
\begin_inset CommandInset citation
LatexCommand cite
key "HTTP2.0Multiplex"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:WebSocket"

\end_inset

WebSocket
\end_layout

\begin_layout Standard
It is a protocol built over 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:HTTP-1.1"

\end_inset

 that allows to create a sort of 
\begin_inset Quotes fld
\end_inset

socket
\begin_inset Quotes frd
\end_inset

 where both the client and the server can send and receive messages at any
 time
\begin_inset CommandInset citation
LatexCommand cite
key "WebSocket"

\end_inset

.
 This is done using an HTTP connection with the 
\begin_inset Quotes fld
\end_inset

keep-alive
\begin_inset Quotes frd
\end_inset

 option.
\end_layout

\begin_layout Standard
So this protocol allows to create efficient realtime notifications, where
 the client receives immediately a notification from the server (for server
 events)
\begin_inset CommandInset citation
LatexCommand cite
key "WebSocketRealTime"

\end_inset

 as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Websocket-with-server"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename websocket.gif
	width 40col%
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Websocket-with-server"

\end_inset

Websocket with server events
\begin_inset CommandInset citation
LatexCommand cite
key "WebsocketImg"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:RESTful"

\end_inset

RESTful
\end_layout

\begin_layout Standard
As shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Modern-web-application"

\end_inset

 we can use 
\begin_inset Quotes fld
\end_inset

RESTful call
\begin_inset Quotes frd
\end_inset

 to retrieve data, RESTful is a sort of protocol to exchange messages between
 the client and the server over HTTP (it uses standard HTTP methods) 
\begin_inset CommandInset citation
LatexCommand cite
key "RESTful"

\end_inset

.
\begin_inset Newline newline
\end_inset

It is a simple protocol that uses the HTTP verbs, for example to create
 a new data a 
\begin_inset Quotes fld
\end_inset

post
\begin_inset Quotes frd
\end_inset

 call must be done, while to update a data a 
\begin_inset Quotes fld
\end_inset

put
\begin_inset Quotes frd
\end_inset

 call must be done, this is the CRUD approach 
\begin_inset CommandInset citation
LatexCommand cite
key "CRUD"

\end_inset

.
 The idea is to do simple actions on resources that return immediately an
 answer (like GET call) or execute immediately an action (like POST call).
\begin_inset Newline newline
\end_inset

There is another protocol older than RESTful, still used: SOAP, it is very
 powerful but as we will see in order to manage resources RESTful is better
 
\begin_inset CommandInset citation
LatexCommand cite
key "RESTSOAP,SOAPvsREST"

\end_inset

.
\end_layout

\begin_layout Standard
RESTful is designed to work with resources, in fact each resource is identified
 by a unique URI and there are standard actions (HTTP verbs) for each resources.
 For example we can have:
\end_layout

\begin_layout Itemize
Customers identified by 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

htttp://example.com/customers
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Customer details with a unique ID (for example id = 10) identified by 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

htttp://example.com/customers/10
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Contacts of a customer identified by 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

htttp://example.com/customers/10/contacts
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
It is easy to understand how this can be useful to surf across a JSON structure
 (the URI can be the reference to a specific level of the JSON structure)
 that we will see on 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:JSON"

\end_inset

.
 In fact, often, RESTful services retrieve JSON data, but they can also
 retrieve XML.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Data-Management"

\end_inset

Data Management
\end_layout

\begin_layout Standard
We will see the basic concepts of database systems to retrieve data in a
 realtime way in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Data-retrieve"

\end_inset

.
\begin_inset Newline newline
\end_inset

Then we see basic concept and issues of data in a distributed system: consistenc
y, partition tolerance and availability in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Consistency,-Partition-tolerance"

\end_inset

.
\begin_inset Newline newline
\end_inset

Finally we see general idea beyond a distributed system in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Partitioning-and-Distribution"

\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Data-retrieve"

\end_inset

Data retrieve
\end_layout

\begin_layout Standard
Relational databases are not developed to send notifications, the basic
 idea is: 
\begin_inset Quotes fld
\end_inset

when you want data you get them
\begin_inset Quotes frd
\end_inset

.
\begin_inset Newline newline
\end_inset

So in the traditional HTTP applications, as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Modern-web-application"

\end_inset

 for each request the HTTP server checks the database server.
\end_layout

\begin_layout Standard
If we want to make this process 
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 we have to solve two main issues:
\end_layout

\begin_layout Enumerate
How to have a notification of a change considering also distributed system
 cases? The trivial solution is the usage of a database 
\begin_inset Quotes fld
\end_inset

trigger
\begin_inset Quotes frd
\end_inset

 as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Database-trigger"

\end_inset

.
\end_layout

\begin_layout Enumerate
How to manage in an efficient way clients that want to have information
 about changes of only some things and not of everything? The solution is
 to use the
\begin_inset Quotes fld
\end_inset

Publish/Subscribe
\begin_inset Quotes frd
\end_inset

 pattern
\begin_inset CommandInset citation
LatexCommand cite
key "PubSubDB"

\end_inset

 as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Publish/Subscribe"

\end_inset

.
\end_layout

\begin_layout Standard
Finally we recap everything needed in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Realtime-retrieve"

\end_inset

.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Database-trigger"

\end_inset

Database trigger
\end_layout

\begin_layout Standard
According to SQL:1999 (known as SQL3) 
\begin_inset CommandInset citation
LatexCommand cite
key "SQL1999"

\end_inset

 a trigger is a procedure automatically called by the database in case of
 some events.
\end_layout

\begin_layout Standard
It has the following components:
\end_layout

\begin_layout Itemize
Unique name
\end_layout

\begin_layout Itemize
Trigger event: insert, delete, update
\end_layout

\begin_layout Itemize
Activation time: before or after the trigger event
\end_layout

\begin_layout Itemize
Trigger granularity: for each row, for each statement
\end_layout

\begin_layout Itemize
Trigger condition: SQL condition
\end_layout

\begin_layout Itemize
trigger actions: SQL procedure to execute
\end_layout

\begin_layout Itemize
trigger timestamp: when the trigger was created
\end_layout

\begin_layout Standard
If the event is fired and the condition is valid the trigger is called,
 if there are more than one trigger to call they are called in timestamp
 ascending order.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Publish/Subscribe"

\end_inset

Publish/Subscribe
\end_layout

\begin_layout Standard
In Publish/Subscribe pattern (originally know as 
\begin_inset Quotes fld
\end_inset

news
\begin_inset Quotes frd
\end_inset

 subsystem) each client that is interested in some data/events 
\begin_inset Quotes fld
\end_inset

subscribes
\begin_inset Quotes frd
\end_inset

 to these ones, while the server service 
\begin_inset Quotes fld
\end_inset

publishes
\begin_inset Quotes frd
\end_inset

 the data that will be sent to the clients (by the broker server(s)) without
 knowing which are the clients 
\begin_inset Quotes fld
\end_inset

subscribed
\begin_inset Quotes frd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "PubSub"

\end_inset

.
 Of course the publishers could not be a server, in fact every actor can
 be a publisher.
\begin_inset Newline newline
\end_inset

Publish/Subscribe is not compatible with RESTful calls since in the RESTful
 approach data must be returned immediately when a request is done as explained
 in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:RESTful"

\end_inset

.
\end_layout

\begin_layout Standard
There are two types of subscriptions:
\end_layout

\begin_layout Itemize
Topic based: channels, i.e.
 an unique name the identifies the messages
\end_layout

\begin_layout Itemize
Content-based: messages sent to subscribers interested to some attributes
 or to the content of them
\end_layout

\begin_layout Standard
The content-based system is more flexible but it is not so easy develop
 an efficient distributed broker network 
\begin_inset CommandInset citation
LatexCommand cite
key "PubSubContent"

\end_inset

.
\end_layout

\begin_layout Standard
Since we need just to receive events of changes on tables the topic-based
 is enough where the topic could be the couple 
\begin_inset Quotes fld
\end_inset

table-record_id
\begin_inset Quotes frd
\end_inset

 as channel.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Realtime-retrieve"

\end_inset

Realtime retrieve
\end_layout

\begin_layout Standard
Now we have all elements to create a 
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 application:
\end_layout

\begin_layout Itemize
Each client 
\begin_inset Quotes fld
\end_inset

subscribes
\begin_inset Quotes frd
\end_inset

 to the data that it needs.
\end_layout

\begin_layout Itemize
A trigger on the server 
\begin_inset Quotes fld
\end_inset

published
\begin_inset Quotes frd
\end_inset

 data when they are updated.
\end_layout

\begin_layout Itemize
The communication between the client and the server is over a websocket
 channel, so immediately after data are published the server sends data
 on this channel.
 As said in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Publish/Subscribe"

\end_inset

 RESTful cannot be used.
\end_layout

\begin_layout Standard
Of course there are still issues related to the distribution and partitioning
 of the infrastructure as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Partitioning-and-Distribution"

\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Consistency,-Partition-tolerance"

\end_inset

Consistency, Partition tolerance, Availability
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename db-triangle.png
	width 80col%
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:-Database-triangle"

\end_inset

Database triangle
\begin_inset CommandInset citation
LatexCommand cite
key "DBTriangle"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:-Database-triangle"

\end_inset

 shows the CAP theorem applied to the databases, it says that in the distributed
 systems only two of the following three properties can be guaranteed 
\begin_inset CommandInset citation
LatexCommand cite
key "CAPNoSQL,CAP"

\end_inset

:
\end_layout

\begin_layout Itemize
Consistency: all nodes receive the most recent data (write)
\end_layout

\begin_layout Itemize
Availability: all requests receive a response with data (this does not ensure
 that data are the newest)
\end_layout

\begin_layout Itemize
Partition tolerance: the system works properly even if data are partitioned
 among nodes, also if some of them are unreachable
\end_layout

\begin_layout Standard
Of course if there are no network errors all properties are hold.
\begin_inset Newline newline
\end_inset

In the distributed systems the main issue is the synchronization among nodes:
 there is no common clock, so it is not so easy to determine the order of
 commits.
\end_layout

\begin_layout Standard
ACID (Atomicity, Consistency, Isolation, Durability) databases (traditional
 relational databases) choose Availability and Consistency 
\begin_inset CommandInset citation
LatexCommand cite
key "CAPNoSQL"

\end_inset

.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "par:Eventual-consistency"

\end_inset

Eventual consistency
\end_layout

\begin_layout Standard
When 
\begin_inset Quotes fld
\end_inset

strong consistency
\begin_inset Quotes frd
\end_inset

 is not implemented, often the 
\begin_inset Quotes fld
\end_inset

eventual consistency
\begin_inset Quotes frd
\end_inset

 is implemented: 
\begin_inset Quotes fld
\end_inset

the storage system guarantees that if no new updates are made to the object,
 eventually all accesses will return the last updated value
\begin_inset Quotes frd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "EventuallyConsistent"

\end_inset

.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "par:CAP-validity"

\end_inset

Today validity
\end_layout

\begin_layout Standard
Today there are new things to consider like partitioned cluster over WAN,
 that can cause different issues such as high latency, so CAP theorem is
 not enough to classify these new situations.
 New classifications are proposed like 
\begin_inset Quotes fld
\end_inset

PACELC
\begin_inset Quotes frd
\end_inset

 to solve these issues 
\begin_inset CommandInset citation
LatexCommand cite
key "CAPValidity"

\end_inset

.
\end_layout

\begin_layout Standard
The idea beyond 
\begin_inset Quotes fld
\end_inset

PACELC
\begin_inset Quotes frd
\end_inset

 is that if 
\begin_inset Quotes fld
\end_inset

strong consistency
\begin_inset Quotes frd
\end_inset

 must be guarantee the latency can increase a lot (time needed to receive
 all acks from all replica for every action), potentially to infinity.
 So a system have to choose between latency and 
\begin_inset Quotes fld
\end_inset

strong consistency
\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Standard
But since this classification is not used yet by a lot of commercial and
 non systems in the next chapters CAP classification will be used, since
 used 
\begin_inset Quotes fld
\end_inset

PACELC
\begin_inset Quotes frd
\end_inset

 would cause the classification inconsistent (since some systems are not
 classified under it).
 Moreover some commercial systems do not give further details to make this
 classification by yourself.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Partitioning-and-Distribution"

\end_inset

Partitioning and Distribution
\end_layout

\begin_layout Standard
There are some systems that use both ideas.
 For example HDFS (a distributed file system) replicates the data among
 nodes and it partitions data among nodes 
\begin_inset CommandInset citation
LatexCommand cite
key "HDFS"

\end_inset

.
 So a chunk of data is replicated some times but it is not present in all
 nodes.
 A group of nodes is called 
\begin_inset Quotes fld
\end_inset

cluster
\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Standard
To elaborate data in a distributed environment one simple, powerful and
 commonly programming model is: MapReduce (shortly explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:MapReduce"

\end_inset

).
\end_layout

\begin_layout Standard
The two main patterns to structure a distributed replicated architecture
 are: 
\begin_inset Quotes fld
\end_inset

multi master
\begin_inset Quotes frd
\end_inset

 and 
\begin_inset Quotes fld
\end_inset

master-salves
\begin_inset Quotes frd
\end_inset

 explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Multi-Master-&-Master-Slaves"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Partitioning
\end_layout

\begin_layout Standard
Partitioning data among different nodes means to split data into chunks
 according to some rules defined and to put different chunks into different
 nodes 
\begin_inset CommandInset citation
LatexCommand cite
key "CAPNoSQL,NoSQL"

\end_inset

.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Distribution"

\end_inset

Distribution
\end_layout

\begin_layout Standard
The distribution is the replication of the infrastructure among different
 nodes, each node does the same thing.
 It is not a so easy concept, in fact there is the synchronization problem
 (formally known as consistency as shown by the 
\begin_inset Quotes fld
\end_inset

CAP
\begin_inset Quotes frd
\end_inset

 theorem explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Consistency,-Partition-tolerance"

\end_inset

) 
\begin_inset CommandInset citation
LatexCommand cite
key "CAP"

\end_inset

 for example in the following scenarios:
\end_layout

\begin_layout Itemize
Commit data in a distributed database: the problem is to find the correct
 commits order since there is no common clock
\end_layout

\begin_layout Itemize
Publish/Subscribe: in a Publish/Subscribe application distributed among
 different nodes, how a published data in a node is sent to all the subscribed
 clients also the ones subscribed on other nodes?
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:MapReduce"

\end_inset

MapReduce
\end_layout

\begin_layout Standard
MapReduce is a programming model where data are split among different nodes
 and are elaborated by different nodes 
\begin_inset CommandInset citation
LatexCommand cite
key "MapReduce"

\end_inset

.
 It is composed by three main actions:
\end_layout

\begin_layout Enumerate
Map: filtering and sorting data
\end_layout

\begin_layout Enumerate
Shuffle: group data by key and send data with the same key to the same reducer
 node
\end_layout

\begin_layout Enumerate
Reduce: summary operations
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Multi-Master-&-Master-Slaves"

\end_inset

Multi Master & Master-Slaves replication
\end_layout

\begin_layout Standard
To have data immediately available (optimistic replication) we have to renounce
 to strong consistency having eventually consistency.
 There are different ways to solve conflicts and obtain eventually consistency,
 one of the simplest ways to solve conflict is 
\begin_inset Quotes fld
\end_inset

Last Writes Wins
\begin_inset Quotes frd
\end_inset

, in this way the writing with the highest timestamps is used overwriting
 the concurrent others 
\begin_inset CommandInset citation
LatexCommand cite
key "OptimisticReplication"

\end_inset

.
\end_layout

\begin_layout Paragraph
\begin_inset CommandInset label
LatexCommand label
name "par:Multi-Master"

\end_inset

Multi Master
\end_layout

\begin_layout Standard
All data can be written in every node of the cluster that replicates them
 to other nodes 
\begin_inset CommandInset citation
LatexCommand cite
key "MultiMasterReplication"

\end_inset

.
 Of course in this kind of architecture there can be issues due to the 
\begin_inset Quotes fld
\end_inset

CAP
\begin_inset Quotes frd
\end_inset

 theorem as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Distribution"

\end_inset

.
\end_layout

\begin_layout Paragraph
Master-Slaves
\end_layout

\begin_layout Standard
All data are written in one node that replicates them to the other that
 can be used only in 
\begin_inset Quotes fld
\end_inset

read only mode
\begin_inset Quotes frd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "MasterSlaveReplication"

\end_inset

.
 Of course in this kind of architecture there are less issues than all the
 issues explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Distribution"

\end_inset

.
 There can be still issues due to 
\begin_inset Quotes fld
\end_inset

Availability
\begin_inset Quotes frd
\end_inset

 as explained by the 
\begin_inset Quotes fld
\end_inset

CAP
\begin_inset Quotes frd
\end_inset

 theorem explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Consistency,-Partition-tolerance"

\end_inset

.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Serverless"

\end_inset

Serverless
\end_layout

\begin_layout Standard
A serverless is a cloud computing architecture, where the developer has
 not to think about the infrastructure.
 It is something at the middle between 
\begin_inset Quotes fld
\end_inset

Platform as a Service
\begin_inset Quotes frd
\end_inset

 and 
\begin_inset Quotes fld
\end_inset

Software as a Service
\begin_inset Quotes frd
\end_inset

, for that reason it is also known as 
\begin_inset Quotes fld
\end_inset

Function as a Service
\begin_inset Quotes frd
\end_inset

.
\begin_inset Newline newline
\end_inset

The serverless idea is a general idea that can be implemented for different
 things, a classic implementation is for file systems 
\begin_inset CommandInset citation
LatexCommand cite
key "ServerlessFilesystem"

\end_inset

.
\end_layout

\begin_layout Standard
In serverless architecture the developer has to think only to develop the
 application without thinking how to scale the infrastructure, how to store
 data in a secure way and so on.
 In serveless architecture the developer has not to develop a real server,
 the server is already set, he has only to configure it and eventually develop
 some small extensions (in the database case the extension can be simply
 the triggers).
\begin_inset Newline newline
\end_inset

Like 
\begin_inset Quotes fld
\end_inset

Function as a Service
\begin_inset Quotes frd
\end_inset

 suggests we can have also systems where we have to develop just a piece
 of code, a function, that is executed in an 
\begin_inset Quotes fld
\end_inset

unknown
\begin_inset Quotes frd
\end_inset

 infrastructure, where we have not to think about scalability, we pay just
 for usage.
 For example we pay the number of execution of that function, this is the
 way used by 
\begin_inset Quotes fld
\end_inset

Amazon AWS
\begin_inset Quotes frd
\end_inset

 implementation: 
\begin_inset Quotes fld
\end_inset

AWS Lambda
\begin_inset Quotes frd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "AWSLambda,AWSLambdaPricing"

\end_inset

.
 This is a big advantage for the user, because there is an instant scalability
 that there is not on 
\begin_inset Quotes fld
\end_inset

Platform as a Service
\begin_inset Quotes frd
\end_inset

 as we will see on 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Platform-as-a"

\end_inset

.
\end_layout

\begin_layout Standard
As we will see on 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Main-Realtime-Databases"

\end_inset

 this kind of architecture is entirely developed on cloud architecture and
 partially developed on Open Source architectures, in open source architecture
 we have the facility to configure and develop the server but we do not
 have an easy scalability like the cloud systems.
\end_layout

\begin_layout Standard
After we will see 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Software-as-a"

\end_inset

 we will know how the difference among these three kinds of architecture
 is minimal and that often there is overlapping among the architectures.
\begin_inset Newline newline
\end_inset

An example of overlapping is 
\begin_inset Quotes fld
\end_inset

Salesforce.com
\begin_inset Quotes frd
\end_inset

, a CRM (customer relationship management) service born like a 
\begin_inset Quotes fld
\end_inset

Software as a Service
\begin_inset Quotes frd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "SAAS"

\end_inset

.
 But it has become a sort of Serverless architecture to build business applicati
ons, it has also bought 
\begin_inset Quotes fld
\end_inset

Heroku
\begin_inset Quotes frd
\end_inset

 a 
\begin_inset Quotes fld
\end_inset

Platform as a Service
\begin_inset Quotes frd
\end_inset

 company.
 However, even if now it is like a serverless service, the price system
 has remained the same as that of 
\begin_inset Quotes fld
\end_inset

Software as a Service
\begin_inset Quotes frd
\end_inset

 system, where you do not pay the usage, you pay for accounts and each account
 has some limits 
\begin_inset CommandInset citation
LatexCommand cite
key "SalesforcePricing"

\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Platform-as-a"

\end_inset

Platform as a Service
\end_layout

\begin_layout Standard
\begin_inset Quotes fld
\end_inset

Platform as a Service
\begin_inset Quotes frd
\end_inset

 is a cloud computing architecture where the developer has not to think
 about infrastructure, he chooses the platform where to develop that is
 automatically configured and ready to use 
\begin_inset CommandInset citation
LatexCommand cite
key "PAAS"

\end_inset

.
 In this kind of architecture the developer has to choose how to scale (it
 can be an automatic process) but in an easy way, often he has only to choose
 the number of nodes.
\end_layout

\begin_layout Standard
One of the most known 
\begin_inset Quotes fld
\end_inset

Platform as a Service
\begin_inset Quotes frd
\end_inset

 service is 
\begin_inset Quotes fld
\end_inset

Heroku
\begin_inset Quotes frd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Heroku"

\end_inset

, comparing the price system of 
\begin_inset Quotes fld
\end_inset

Heroku
\begin_inset Quotes frd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "HerokuPricing"

\end_inset

 with the price system of 
\begin_inset Quotes fld
\end_inset

AWS Lambda
\begin_inset Quotes frd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "AWSLambdaPricing"

\end_inset

 we can see that in 
\begin_inset Quotes fld
\end_inset

Heroku
\begin_inset Quotes frd
\end_inset

 we pay for number of nodes per seconds, while in 
\begin_inset Quotes fld
\end_inset

AWS Lambda
\begin_inset Quotes frd
\end_inset

 we pay just for execution time.
 In 
\begin_inset Quotes fld
\end_inset

AWS Lambda
\begin_inset Quotes frd
\end_inset

 we have not to do anything to execute just one 
\begin_inset Quotes fld
\end_inset

function
\begin_inset Quotes frd
\end_inset

 per second or thousands per second, while on 
\begin_inset Quotes fld
\end_inset

Heroku
\begin_inset Quotes frd
\end_inset

 we have to set the right number of nodes or set a correct strategy to dynamical
ly create/remove nodes.
 So the serverless approach can reach the maximum grade of sharing resources
 in cloud computing.
\end_layout

\begin_layout Standard
For what concerns the concept of platform ready to use to develop the serverless
 architecture is similar to 
\begin_inset Quotes fld
\end_inset

Platform as a Service
\begin_inset Quotes frd
\end_inset

 but it is different for other things like scalability as we have seen with
 
\begin_inset Quotes fld
\end_inset

AWS Lambda
\begin_inset Quotes frd
\end_inset

 example.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Software-as-a"

\end_inset

Software as a Service
\end_layout

\begin_layout Standard
\begin_inset Quotes fld
\end_inset

Software as a service
\begin_inset Quotes frd
\end_inset

 is a cloud computing architecture where there is no need or possibility
 to develop anything 
\begin_inset CommandInset citation
LatexCommand cite
key "SAAS"

\end_inset

.
 One classic example is a webmail service, that can be configured for a
 private company.
\end_layout

\begin_layout Standard
One of the most known 
\begin_inset Quotes fld
\end_inset

Software as a Service
\begin_inset Quotes frd
\end_inset

 service is 
\begin_inset Quotes fld
\end_inset

Google apps for work
\begin_inset Quotes frd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "GoogleWork"

\end_inset

, a service where the employees of a company have access to company mail,
 company docs, company cloud storage and so on; everything is done only
 by configuring a system without developing anything.
 The price system of 
\begin_inset Quotes fld
\end_inset

Google apps for work
\begin_inset Quotes frd
\end_inset

 is a system where the company has to pay for the number of users not for
 the usage 
\begin_inset CommandInset citation
LatexCommand cite
key "GoogleWorkPricing"

\end_inset

, an approach completely different from other cloud systems, but it is a
 good approach for companies because in that way they are able to predict
 the cost in a reliable way.
\end_layout

\begin_layout Standard
The serverless approach is very similar to 
\begin_inset Quotes fld
\end_inset

Software as a Service
\begin_inset Quotes frd
\end_inset

 since the developer has not to think about the infrastructure or how to
 build a reliable server, but instead of the 
\begin_inset Quotes fld
\end_inset

Software as a Service
\begin_inset Quotes frd
\end_inset

 in the serverless architecture the developer can develop something, not
 only configure.
\end_layout

\end_body
\end_document
