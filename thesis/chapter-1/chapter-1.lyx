#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\options openright
\use_default_options false
\master ../thesis.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding T1
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Indice
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
Since we will cover only HTTP based application we will start analyzing
 an HTTP application stack on 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Traditional-HTTP-Application"

\end_inset

.
 Then we will see how to send realtime notifications of changes and the
 limits that are the causes of the creation of NoSQL databases.
 Finally we will analyze the NoSQL databases approach on 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Realtime-databases-stack"

\end_inset

.
\begin_inset Newline newline
\end_inset

Of course the protocol is not the only element needed to build an application
 that receives realtime notifications of changes but it is a must.
 Without a right protocol, that allows us to receive messages from the server,
 we are not able to build an efficient application that receives 
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 notifications of changes.
\end_layout

\begin_layout Standard
We will also analyze the database itself, because in traditional databases
 there is no native event notification system: we have to check it every
 time (polling) or we have to create a trigger to do that as we will see
 in the next sections.
 Of course the NoSQL databases that we will analyze solve this.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Traditional-HTTP-Application"

\end_inset

Traditional HTTP Application Stack
\end_layout

\begin_layout Standard
There are a lot of ways to build an Application over HTTP, a web application,
 but all have common parts.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename web-stack.png
	width 90col%
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Modern-web-application"

\end_inset

Modern web application stack
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In all the classical HTTP applications we have:
\end_layout

\begin_layout Enumerate
the client requests something to the HTTP server (application server)
\end_layout

\begin_layout Enumerate
the HTTP server (application server) requests data to Database Server
\end_layout

\begin_layout Enumerate
the HTTP server (application server) sends the data to the client
\end_layout

\begin_layout Standard
as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Modern-web-application"

\end_inset

.
\end_layout

\begin_layout Standard
We will see the evolution of the HTTP that allows to send realtime notifications.
 The core of the issue is the HTTP handshake, in fact we need to have asynchrono
us requests, i.e.
 the server should be able to send messages to the client at any time 
\begin_inset CommandInset citation
LatexCommand cite
key "SyncAsync"

\end_inset

.
\end_layout

\begin_layout Subsection
HTTP handshake
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:HTTP-1.0"

\end_inset

HTTP 1.0
\end_layout

\begin_layout Standard
The original version of HTTP (HTTP 1.0) allowed just connections that must
 be closed immediately after the receiving of data 
\begin_inset CommandInset citation
LatexCommand cite
key "HTTP1.0"

\end_inset

, as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:HTTP1.0-vs-HTTP1.1"

\end_inset

 (first image):
\end_layout

\begin_layout Enumerate
The client requests something
\end_layout

\begin_layout Enumerate
The server replies
\end_layout

\begin_layout Enumerate
The connection is closed
\end_layout

\begin_layout Standard
In this version the only approaches available to make realtime notifications
 are:
\end_layout

\begin_layout Itemize
Short polling: schedule new request every fixed small amount of time to
 check if the data are changed
\end_layout

\begin_layout Itemize
Long polling: create a normal request to the server.
 But the server replies only when there are new data, then the client creates
 a new request
\end_layout

\begin_layout Itemize
Event Stream: a long request without end, where the server continues to
 send data to the client, this approach is used in video/music streaming.
\end_layout

\begin_layout Standard
All approaches have a lot of issues that reduce the performances
\begin_inset CommandInset citation
LatexCommand cite
key "PollingStreamProblems"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename HTTP1.png
	width 70col%
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:HTTP1.0-vs-HTTP1.1"

\end_inset

HTTP1.0 vs HTTP1.1 (using
\begin_inset Quotes fld
\end_inset

keep-alive
\begin_inset Quotes frd
\end_inset

)
\begin_inset CommandInset citation
LatexCommand cite
key "HTTPPersistent"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:HTTP-1.1"

\end_inset

HTTP 1.1
\end_layout

\begin_layout Standard
It is a new version of HTTP that fixed some issues and improved some things,
 it enabled the 
\begin_inset Quotes fld
\end_inset

keep-alive
\begin_inset Quotes frd
\end_inset

 option (this option was implemented unofficially by a lot of HTTP 1.0 clients)
\begin_inset CommandInset citation
LatexCommand cite
key "HTTP1.1"

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Quotes fld
\end_inset

keep-alive
\begin_inset Quotes frd
\end_inset

 option allows to use the same connection multiple times, i.e.
 after a server replies the client can send another message over the same
 connection as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:HTTP1.0-vs-HTTP1.1"

\end_inset

 (second image).
\begin_inset Newline newline
\end_inset

This was originally projected to request different files over the same connectio
n.
 But it allowed to do a lot of other things, as we will see in the section
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:WebSocket"

\end_inset

 it is the enabling technology for websocket.
\end_layout

\begin_layout Subsubsection
HTTP 2.0
\end_layout

\begin_layout Standard
It is the newest HTTP standard (2015), it introduced a lot of improvements.
 The most important are: the possibility for the server to 
\begin_inset Quotes fld
\end_inset

push
\begin_inset Quotes frd
\end_inset

 data, that the client has not requested explicitly and the possibility
 to have multiple parallel requests over a single TCP connection as shown
 in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:HTTP2-multiple-parallel"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "HTTP2.0"

\end_inset

.
 These features allow also to increase the energy efficiency
\begin_inset CommandInset citation
LatexCommand cite
key "HTTP2.0Energy"

\end_inset

.
\end_layout

\begin_layout Standard
But, since it is new, it is not supported in an efficient way by a lot of
 browsers
\begin_inset CommandInset citation
LatexCommand cite
key "HTTP2.0Support"

\end_inset

 and by a lot of websites
\begin_inset CommandInset citation
LatexCommand cite
key "HTTP2.0WebSites"

\end_inset

.
 So at the moment other solutions are preferred (like websocket).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename HTTP2.png
	width 90col%
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:HTTP2-multiple-parallel"

\end_inset

HTTP2 multiple parallel requests
\begin_inset CommandInset citation
LatexCommand cite
key "HTTP2.0Multiplex"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:WebSocket"

\end_inset

WebSocket
\end_layout

\begin_layout Standard
It is a protocol built over 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:HTTP-1.1"

\end_inset

 that allows to create a sort of 
\begin_inset Quotes fld
\end_inset

socket
\begin_inset Quotes frd
\end_inset

 where both the client and the server can send and receive messages at any
 time
\begin_inset CommandInset citation
LatexCommand cite
key "WebSocket"

\end_inset

.
 This is done using an HTTP connection with the 
\begin_inset Quotes fld
\end_inset

keep-alive
\begin_inset Quotes frd
\end_inset

 option.
\end_layout

\begin_layout Standard
So this protocol allows to create efficient realtime notifications, where
 the client receives immediately a notification from the server (for server
 events)
\begin_inset CommandInset citation
LatexCommand cite
key "WebSocketRealTime"

\end_inset

 as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Websocket-with-server"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename websocket.gif
	width 40col%
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:Websocket-with-server"

\end_inset

Websocket with server events
\begin_inset CommandInset citation
LatexCommand cite
key "WebsocketImg"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:RESTful"

\end_inset

RESTful
\end_layout

\begin_layout Standard
As shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Modern-web-application"

\end_inset

 we can use 
\begin_inset Quotes fld
\end_inset

RESTful call
\begin_inset Quotes frd
\end_inset

 to retrieve data, RESTful is a sort of protocol to exchange messages between
 the client and the server over HTTP (it uses standard HTTP methods) 
\begin_inset CommandInset citation
LatexCommand cite
key "RESTful"

\end_inset

.
\begin_inset Newline newline
\end_inset

It is a simple protocol that uses the HTTP verbs, for example to create
 a new data a 
\begin_inset Quotes fld
\end_inset

post
\begin_inset Quotes frd
\end_inset

 call must be done, while to update a data a 
\begin_inset Quotes fld
\end_inset

put
\begin_inset Quotes frd
\end_inset

 call must be done, this is the CRUD approach 
\begin_inset CommandInset citation
LatexCommand cite
key "CRUD"

\end_inset

.
 The idea is to do simple actions on resources that return immediately an
 answer (like GET call) or execute immediately an action (like POST call).
\begin_inset Newline newline
\end_inset

There is another protocol older than RESTful, still used: SOAP, it is very
 powerful but as we will see in order to manage resources RESTful is better
 
\begin_inset CommandInset citation
LatexCommand cite
key "RESTSOAP,SOAPvsREST"

\end_inset

.
\end_layout

\begin_layout Standard
RESTful is designed to work with resources, in fact each resource is identified
 by a unique URI and there are standard actions (HTTP verbs) for each resources.
 For example we can have:
\end_layout

\begin_layout Itemize
Customers identified by 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

htttp://example.com/customers
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Customer details with a unique ID (for example id = 10) identified by 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

htttp://example.com/customers/10
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Contacts of a customer identified by 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

htttp://example.com/customers/10/contacts
\end_layout

\end_inset


\end_layout

\end_deeper
\end_deeper
\begin_layout Standard
It is easy to understand how this can be useful to surf across a JSON structure
 (the URI can be the reference to a specific level of the JSON structure)
 that we will see on 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:JSON"

\end_inset

.
 In fact, often, RESTful services retrieve JSON data, but they can also
 retrieve XML.
\end_layout

\begin_layout Standard
We will see real examples on 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:RESTful-Approach"

\end_inset

.
 
\series bold
TODO CHECKME
\end_layout

\begin_layout Subsection
Data retrieve
\end_layout

\begin_layout Standard
Relational databases are not developed to send notifications, the basic
 idea is: 
\begin_inset Quotes fld
\end_inset

when you want data you get them
\begin_inset Quotes frd
\end_inset

.
\begin_inset Newline newline
\end_inset

So in the traditional HTTP applications, as shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Modern-web-application"

\end_inset

 for each request the HTTP server checks the database server.
\end_layout

\begin_layout Standard
If we want to make this process 
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 we have to solve two main issues:
\end_layout

\begin_layout Enumerate
How to have a notification of a change considering also distributed system
 cases? The trivial solution is the usage of a database 
\begin_inset Quotes fld
\end_inset

trigger
\begin_inset Quotes frd
\end_inset

 as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Database-trigger"

\end_inset

.
\end_layout

\begin_layout Enumerate
How to manage in an efficient way clients that want to have information
 about changes of only some things and not of everything? The solution is
 to use the
\begin_inset Quotes fld
\end_inset

Publish/Subscribe
\begin_inset Quotes frd
\end_inset

 pattern
\begin_inset CommandInset citation
LatexCommand cite
key "PubSubDB"

\end_inset

 as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Publish/Subscribe"

\end_inset

.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Database-trigger"

\end_inset

Database trigger
\end_layout

\begin_layout Standard
A trigger is a small snippet of code that is executed for some events such
 as the insertion of data into a row.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Publish/Subscribe"

\end_inset

Publish/Subscribe
\end_layout

\begin_layout Standard
In Publish/Subscribe pattern each client that is interested in some data/events
 
\begin_inset Quotes fld
\end_inset

subscribes
\begin_inset Quotes frd
\end_inset

 to these ones (they are called 
\begin_inset Quotes fld
\end_inset

channels
\begin_inset Quotes frd
\end_inset

), while the server service 
\begin_inset Quotes fld
\end_inset

publishes
\begin_inset Quotes frd
\end_inset

 the data that will be sent to the clients without knowing which are the
 client 
\begin_inset Quotes fld
\end_inset

subscribed
\begin_inset Quotes frd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "PubSub"

\end_inset

.
 Of course Publish/Subscribe is not compatible with RESTful calls since
 in the RESTful approach data must be returned immediately when a request
 is done as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:RESTful"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Realtime retrieve
\end_layout

\begin_layout Standard
Now we have all elements to create a 
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 application:
\end_layout

\begin_layout Itemize
Each client 
\begin_inset Quotes fld
\end_inset

subscribes
\begin_inset Quotes frd
\end_inset

 to the data that it needs.
\end_layout

\begin_layout Itemize
A trigger on the server 
\begin_inset Quotes fld
\end_inset

published
\begin_inset Quotes frd
\end_inset

 data when they are updated.
\end_layout

\begin_layout Itemize
The communication between the client and the server is over a websocket
 channel, so immediately after data are published the server sends data
 on this channel.
 As said in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Publish/Subscribe"

\end_inset

 RESTful cannot be used.
\end_layout

\begin_layout Standard
Of course there are still issues related to the distribution and partitioning
 of the infrastructure as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Partitioning-and-Distribution"

\end_inset

.
\end_layout

\end_body
\end_document
