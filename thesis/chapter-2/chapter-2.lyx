#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\options openright
\use_default_options false
\master ../thesis.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding T1
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Indice
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
As we have seen in the previous section with a standard HTTP application
 stack we can create a 
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 application, so why were these NoSQL 
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 databases born?
\begin_inset Newline newline
\end_inset

They were born to increase the performance and to allow to send realtime
 notifications in an easier way (without implementing manually the entire
 stack).
\end_layout

\begin_layout Standard
We will analyze the key aspects of these NoSQL 
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 database in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Realtime-databases-stack"

\end_inset

.
 
\begin_inset Newline newline
\end_inset

Then we will see best practices from client to receive notification (using
 publish/subscribe) in a trasparent way for the final user point of view
 in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Client-best-practices"

\end_inset

.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Realtime-databases-stack"

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "subsec:NoSQL-databases"

\end_inset

NoSQL 
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 databases
\end_layout

\begin_layout Standard
They are improperly called 
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 even if they are a not realtime databases, but this name is used for commercial
 purpose since they send 
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 notifications of changes in data.
\end_layout

\begin_layout Standard
The advantages of these databases are:
\end_layout

\begin_layout Itemize
They can be easily partitioned and distributed over different nodes, an
 important property as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Distributed-issues"

\end_inset


\end_layout

\begin_layout Itemize
They allow easily to subscribe to different granularity of data and receive
 notification of changes using publish/subscribe as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Publish/subscribeNOSQL"

\end_inset

.
 This is done without writing any line of code in the server.
 They implement also the publish/subscribe broker server.
\end_layout

\begin_layout Itemize
They can be easily implemented in a serverless approach as explained in
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Serverless"

\end_inset

, an efficient approach that can also give a lot of economic advantages
 in different situations.
\end_layout

\begin_layout Itemize
They implement client best practices providing all libraries/framework explained
 in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Client-best-practices"

\end_inset


\end_layout

\begin_layout Standard
It's easy to see why these databases are implemented over NoSQL databases.
\end_layout

\begin_layout Standard
In fact a NoSQL database is an unstructured database, it can support a subset
 of the SQL instructions (but it is not mandatory).
\begin_inset Newline newline
\end_inset

They were born to create scalable databases for Big Data (a set of data
 that are too large or too complex to be managed/elaborated with a traditional
 system) applications.
 Even this means losing query expressivity power, in fact they can have
 
\begin_inset Quotes fld
\end_inset

multiple masters
\begin_inset Quotes frd
\end_inset

 support explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:Multi-Master"

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "NoSQL"

\end_inset

.
\end_layout

\begin_layout Standard
They can be easily partitioned but in order to ensure this efficiently they
 have to renounce to the Consistency or to the Availability as shown in
 the figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:-Database-triangle"

\end_inset

 (more details are explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Distributed-issues"

\end_inset

), we will see more details analyzing real applications in 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:technologies"

\end_inset

.
\end_layout

\begin_layout Standard
Data are stored unstructured formats, as we will analyze in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Data-models"

\end_inset

.
\begin_inset Newline newline
\end_inset

Then we will see distributed issues with pro and cons in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Distributed-issues"

\end_inset

.
\begin_inset Newline newline
\end_inset

Finally we will see publish/subscribe implemented in these databases in
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Publish/subscribeNOSQL"

\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Data-models"

\end_inset

Data model
\end_layout

\begin_layout Standard
Data are organized in 
\begin_inset Quotes fld
\end_inset

documents
\begin_inset Quotes frd
\end_inset

 not tables 
\begin_inset CommandInset citation
LatexCommand cite
key "CAPNoSQL"

\end_inset

.
 Each document is something that can contain data in JSON format, file or
 other things.
\begin_inset Newline newline
\end_inset

Of course a database can have more than one 
\begin_inset Quotes fld
\end_inset

table
\begin_inset Quotes frd
\end_inset

, where 
\begin_inset Quotes fld
\end_inset

table
\begin_inset Quotes frd
\end_inset

 is a collection of documents.
 Often they are not called 
\begin_inset Quotes fld
\end_inset

table
\begin_inset Quotes frd
\end_inset

 since they are not a table (they are unstructured data) but it is used
 since it identify the key concept: collection of documents.
\end_layout

\begin_layout Standard
We will see two main types of data models: key-value and JSON.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:key-value"

\end_inset

key-value
\end_layout

\begin_layout Standard
Key-value is one of the simplest ways to store unstructured data it is also
 known as dictionary or hash
\begin_inset CommandInset citation
LatexCommand cite
key "CAPNoSQL"

\end_inset

.
 The basic idea is that we have unique keys and for each of them we have
 a value linked, i.e.
 a document that can be everything: a file, a simple type a complex type
 (like JSON) and so on.
\end_layout

\begin_layout Standard
The simplicity of this schema is its key of th success, in fact it is used
 in a lot of NoSQL systems.
\end_layout

\begin_layout Standard
If we want to apply publish/subscribe (explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Publish/Subscribe"

\end_inset

) we can easily use topic based publish/subscribe using the couple 
\begin_inset Quotes fld
\end_inset

table-key
\begin_inset Quotes frd
\end_inset

 as channel.
 So the only level of granularity is the value (low granularity), we do
 not inspect it.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:JSON"

\end_inset

JSON
\end_layout

\begin_layout Standard
JSON (JavaScript Object Notation) is an easy standard to store data 
\begin_inset CommandInset citation
LatexCommand cite
key "JSON"

\end_inset

, it is not so powerful like XML but it is simpler so the computation is
 faster 
\begin_inset CommandInset citation
LatexCommand cite
key "JSONvsXML"

\end_inset

.
 On listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Simple-JSON-example"

\end_inset

 there is a simple example of a JSON structure.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,commentstyle={\color{purple!60!black}},extendedchars=true,identifierstyle={\color{blue!50!black}},keywordstyle={\bfseries\color{green!50!black}},language=JavaScript,numbers=left,numberstyle={\footnotesize},showstringspaces=false,stringstyle={\color{orange!40!black}},tabsize=4,xleftmargin=2em"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Simple-JSON-example"

\end_inset

Simple JSON example
\end_layout

\end_inset

{
\end_layout

\begin_layout Plain Layout

	"main_array":[
\end_layout

\begin_layout Plain Layout

		[
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				"title": "Element 11"
\end_layout

\begin_layout Plain Layout

			},
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				"title": "Element 12"
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		],
\end_layout

\begin_layout Plain Layout

		[
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				"title": "Element 21"
\end_layout

\begin_layout Plain Layout

			},
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				"title": "Element 22"
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		]
\end_layout

\begin_layout Plain Layout

	]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
On the JSON structure there can be simple types, array or objects, in the
 previous example (listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Simple-JSON-example"

\end_inset

) we have:
\end_layout

\begin_layout Itemize
main object
\end_layout

\begin_deeper
\begin_layout Itemize
an array (called 
\begin_inset Quotes fld
\end_inset

main_array
\begin_inset Quotes frd
\end_inset

)
\end_layout

\begin_deeper
\begin_layout Itemize
two arrays
\end_layout

\begin_deeper
\begin_layout Itemize
two objects (with 
\begin_inset Quotes fld
\end_inset

title
\begin_inset Quotes frd
\end_inset

 property)
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
So in a NoSQL database that uses JSON a 
\begin_inset Quotes fld
\end_inset

document
\begin_inset Quotes frd
\end_inset

 is composed by a JSON data like that.
 This structure is a very powerful structure that allows to store a lot
 of complex structures.
\end_layout

\begin_layout Standard
A simple example can be a system where we have some users, each of them
 with a complex structure, each user is stored as object in a main array.
\begin_inset Newline newline
\end_inset

We will see this case and others on the chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:class-of-applications"

\end_inset

.
\end_layout

\begin_layout Standard
As introduced in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:RESTful"

\end_inset

 the RESTful is a good protocol for JSON and, in general, NoSQL databases
 
\begin_inset CommandInset citation
LatexCommand cite
key "RESTNOSQL"

\end_inset

.
\end_layout

\begin_layout Standard
It is easy to see how this structure can be useful to 
\begin_inset Quotes fld
\end_inset

subscribe
\begin_inset Quotes frd
\end_inset

 only to a portion of data, to a 
\begin_inset Quotes fld
\end_inset

path
\begin_inset Quotes frd
\end_inset

.
 For example using a structure like the one used in listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Simple-JSON-example"

\end_inset

, we can subscribe to the second element of the main array (an inner array)
 then we receive notification for changes of it (or other inner elements
 also complex elements).
 So we can have an high granularity, different systems have different limit
 on max number of levels allowed.
\begin_inset Newline newline
\end_inset

If we want to apply publish/subscribe (explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Publish/Subscribe"

\end_inset

) we can easily use topic based publish/subscribe using the couple 
\begin_inset Quotes fld
\end_inset

table-path
\begin_inset Quotes frd
\end_inset

 as channel.
\begin_inset Newline newline
\end_inset

We can also see that the expresivity power is the same of 
\begin_inset Quotes fld
\end_inset

key-value
\begin_inset Quotes frd
\end_inset

 since we can consider path as our key (of course the structure of data
 stored is different), but it is more readable.
\end_layout

\begin_layout Standard
We see better what it means to 
\begin_inset Quotes fld
\end_inset

subscribe
\begin_inset Quotes frd
\end_inset

 to a specif 
\begin_inset Quotes fld
\end_inset

path
\begin_inset Quotes frd
\end_inset

 of the JSON structure in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Event-driven-approach"

\end_inset

.
\end_layout

\begin_layout Standard
We can see that if we have just one main object the final result is the
 same of a 
\begin_inset Quotes fld
\end_inset

key-value
\begin_inset Quotes frd
\end_inset

 structure.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Distributed-issues"

\end_inset

Distributed issues
\end_layout

\begin_layout Standard
As introduced at the beginning NoSQL databases can be easily distributed
 and partitioning, we obtain an increase of performance from distribution
 and partitioning as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Distribution-and-partitioningNOSQL"

\end_inset

 but we have to renounce to 
\begin_inset Quotes fld
\end_inset

strong consistency
\begin_inset Quotes frd
\end_inset

 as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:CAP-theoremNOSQL"

\end_inset


\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:CAP-theoremNOSQL"

\end_inset

CAP theorem
\end_layout

\begin_layout Standard
As introduced in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Consistency,-Partition-tolerance"

\end_inset

 the cap theorem is one of the fundamental theorem for distributed databases.
\end_layout

\begin_layout Standard
Since the main characteristic of them is the scalability they need partition
 tolerance.
 In fact NoSQL, often, chooses Availability and Partition tolerance or Consisten
cy and Partition tolerance 
\begin_inset CommandInset citation
LatexCommand cite
key "CAPNoSQL"

\end_inset

.
 In the chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:technologies"

\end_inset

 we will see NoSQL databases of both types.
\end_layout

\begin_layout Standard
Since, often, they don't implement a 
\begin_inset Quotes fld
\end_inset

strong consistency
\begin_inset Quotes frd
\end_inset

 an 
\begin_inset Quotes fld
\end_inset

eventually consistency
\begin_inset Quotes frd
\end_inset

 is implemented, explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "par:Eventual-consistency"

\end_inset

.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Distribution-and-partitioningNOSQL"

\end_inset

Distribution and partitioning
\end_layout

\begin_layout Standard
As introduced in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Partitioning-and-Distribution"

\end_inset

 distribution and partitioning introduce different issues.
\begin_inset Newline newline
\end_inset

But in NoSQL databases also the master node can be distributed, so the client
 can commit on different nodes.
 This increases the performance, since there are no saturation issues of
 the server or of the locks needed to write data (commit) 
\begin_inset CommandInset citation
LatexCommand cite
key "NoSQL"

\end_inset

.
\end_layout

\begin_layout Subsection

\series bold
\begin_inset CommandInset label
LatexCommand label
name "subsec:Publish/subscribeNOSQL"

\end_inset

Publish/subscribe
\end_layout

\begin_layout Standard
As introduced in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Data-models"

\end_inset

 topic-based subscription is enough (explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Publish/Subscribe"

\end_inset

).
\end_layout

\begin_layout Standard
The common idea in all of these databases is to subscribe to main events
 (the same events of database trigger explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Database-trigger"

\end_inset

):
\end_layout

\begin_layout Itemize
inserted
\end_layout

\begin_layout Itemize
updated
\end_layout

\begin_layout Itemize
deleted
\end_layout

\begin_layout Standard
We subscribe to these events for different level of granularity, that depends
 on the data model used and on the database itself.
 For example there are some databases that, even if they support JSON, they
 allow to subscribe only to the first level of it (so it is like a key-value).
\begin_inset Newline newline
\end_inset

Of course, as introduced at the beginning, the mechanism to subscribe to
 these data and the 
\begin_inset Quotes fld
\end_inset

trigger
\begin_inset Quotes frd
\end_inset

 that publishes them are developed inside these databases.
 So no other development is required, the system is ready to publish changes.
 The delivery can be implemented using different technologies that we have
 analyzed in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Traditional-HTTP-Application"

\end_inset

.
 
\end_layout

\begin_layout Standard
Of course we still have issues due to the fact that we have to scale also
 the broker servers and as said in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Publish/Subscribe"

\end_inset

 it's not an easy task (even if for topic-based is easier than content-based).
 Fortunately these databases provide an integrated publish/subscribe that
 scales with the database itself.
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "subsec:Client-best-practices"

\end_inset

Client best practices
\end_layout

\begin_layout Standard
In this sub section we will see the best practices used in these kind of
 applications from the client point of view.
 Some choices, like data returned in some cases, can be imposed by the server
 technology chosen.
 On figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:client-architecture"

\end_inset

 a simple architecture is shown.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/client_architecture.png
	width 70col%
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:client-architecture"

\end_inset

Simple client architecture
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Of course, since there is no standard, any application implement different
 things and/or implement them in different ways.
 So this is just a summary of the most used best practices.
\end_layout

\begin_layout Standard
We can summary them as:
\end_layout

\begin_layout Itemize
The client don't contact directly the application server but send all requests
 to the client framework.
 It receives immediately a response with an 
\begin_inset Quotes fld
\end_inset

eventually consistency logic
\begin_inset Quotes frd
\end_inset

 (a read doesn't return a data older than a previous read), but of course
 the data cannot be updated with the latest of the server.
\end_layout

\begin_layout Itemize
The servers send asynchronous notification of changes, the client catch
 them using an event driven approach explained in 
\series bold

\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Event-driven-approach"

\end_inset


\series default
.
 The client specify which data he needs, so he receives notifications only
 for them.
\end_layout

\begin_layout Itemize
The client uses a language that allows easily to work with event driven
 approach as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Client-language"

\end_inset

.
\end_layout

\begin_layout Itemize
The client framework uses RESTful to send/receive synchronously data explained
 in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:RESTful-Approach"

\end_inset

.
\end_layout

\begin_layout Itemize
The client framework implements a local database, it stores all data written
 by the client and all data received by the server via asynchronous notification
s as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Local-database"

\end_inset

.This allows to return data immediately when request by the client.
\end_layout

\begin_layout Standard
All things allow to use efficiently publish/subscribe to receive data in
 a transparent way for final user.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Event-driven-approach"

\end_inset

Event driven approach
\end_layout

\begin_layout Standard
On algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Event-driven-retrieve"

\end_inset

 we show a common and simple realtime retrieve of data in event driven approach.
 The basic idea of event driven approach is to call a callback when an event
 is fired, a known example of event driven programming is programming for
 desktop interfaces where the events are the user inputs.
\begin_inset Newline newline
\end_inset

Of course this is not the only approach available but it is easy to understand
 how it is very useful in asynchronous applications like 
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 applications that we discuss in this thesis.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Event-driven-retrieve"

\end_inset

Event driven retrieve of data
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout

	
\backslash
State $db 
\backslash
gets 
\backslash
Call{connect}{DB
\backslash
_ADDRESS}$ 
\backslash
Comment{Connect to DB}
\end_layout

\begin_layout Plain Layout

	
\backslash
State $document 
\backslash
gets 
\backslash
Call{selectDocument}{db, DOCUMENT}$ 
\backslash
Comment{Select document}
\end_layout

\begin_layout Plain Layout

	
\backslash
State $
\backslash
Call{onChange}{document, PATH, CALLBACK}$ 
\backslash
Comment{Subscribe to change events}
\end_layout

\begin_layout Plain Layout

	
\backslash
Procedure{callback}{newVal, oldVal}
\end_layout

\begin_layout Plain Layout

		
\backslash
State $
\backslash
Call{log}{oldVal}$ 
\backslash
Comment{Log new value of the path}
\end_layout

\begin_layout Plain Layout

		
\backslash
State $
\backslash
Call{log}{newVal}$ 
\backslash
Comment{Log old value of the path}
\end_layout

\begin_layout Plain Layout

	
\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The basic idea is to subscribe a callback to change events of a specif path
 of a document, thinking of JSON documents the path is a reference to a
 specif level of the JSON document.
 For example a path for the JSON listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Simple-JSON-example"

\end_inset

 can be 
\begin_inset Quotes fld
\end_inset

/main_array/0/
\begin_inset Quotes frd
\end_inset

 to subscribe to change events of the first array inside main array.
\begin_inset Newline newline
\end_inset

On the callback the entire new path can be passed or only the part changed,
 in the case of an array only the child changed.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Client-language"

\end_inset

Client language
\end_layout

\begin_layout Standard
One of the language most used in this kind of applications is EcmaScript
 5.0 (in some cases EcmaScript 6.0), commonly known with its dialect name:
 javascript.
 In fact the most known EcmaScript interpreter: V8 is very efficient for
 event driven programs, it is the interpreter used by the desktop porting
 that we will use: nodejs 
\begin_inset CommandInset citation
LatexCommand cite
key "NodeEventDriven"

\end_inset

.
 This efficiency is due to a good Just in Time compiler written in C 
\begin_inset CommandInset citation
LatexCommand cite
key "V8"

\end_inset

.
 All server technologies chosen analyzed in the next chapters have EcmaScript
 clients, of course we can create clients in other languages since the protocols
 used are standard and opened.
 EcmaScript is a language where event driven approach is easy to implement,
 in fact the language has the fundamentals to execute the asynchronous code
 since it has the callbacks 
\begin_inset CommandInset citation
LatexCommand cite
key "SyncAsync,AJAX"

\end_inset

.
\series bold

\begin_inset Newline newline
\end_inset


\series default
Moreover EcamScript is executed in only one thread, also the callbacks are
 executed in this thread.
 But some operations like network requests, database connections and so
 on are executed by other threads in background (the result is passed to
 the callback called in the main thread).
 If there is no CPU intensive code, this approach is very efficient and
 solves problems due to race conditions 
\begin_inset CommandInset citation
LatexCommand cite
key "NodeEventDriven"

\end_inset

.
\series bold

\begin_inset Newline newline
\end_inset


\series default
Nodejs has also a standard packet manager called NPM, with a lot of libraries,
 this allows to write small examples with only the code needed to understand,
 the other parts are done by the libraries.
\end_layout

\begin_layout Standard
Furthermore JSON, as the acronym suggests, is derived from javascript.
 In fact the javascript can parse it easily and JSON objects/arrays become
 javascript native objects/arrays.
 So we can access to them in a native way without calling parsing methods
 to iterate the structure or without mapping the JSON into already defined
 classes (i.e.
 deserialize it to objects), like other languages do like JAVA 
\begin_inset CommandInset citation
LatexCommand cite
key "JAVAJSON"

\end_inset

, in fact both approaches are not easily adaptable to structure changes.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:RESTful-Approach"

\end_inset

RESTful Approach
\end_layout

\begin_layout Standard
What we said previously in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Event-driven-approach"

\end_inset

 for path is valid also for RESTful URI as introduced in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:RESTful"

\end_inset

.
 RESTful is useful to post/put/delete data and to retrieve them in an synchronou
s way, synchronous retrieve can be useful to populate local databases (explained
 in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Local-database"

\end_inset

) at the beginning, in fact RESTful is not compatible with asynchronous
 requests.
 There is no reason to do this kind of operations in an asynchronous way,
 of course they can be done via a websocket connection, but they are done
 in a sort of synchronous way.
\end_layout

\begin_layout Standard
So the best practice is to use RESTful for all synchronous operations, let
 the possibility to use RESTful get all data or a portion of them, but give
 also an asynchronous
\end_layout

\begin_layout Standard
interface integrated with the event driven approach like websocket.
\end_layout

\begin_layout Standard
Of course since JavaScript has asynchronous operations support the result
 of these synchronous operations is returned via a callback.
 These operations are synchronous, in the meaning that after the request
 is sent a response is returned immediately, but there are network delays,
 for that reason the code is executed in an asynchronous way 
\begin_inset CommandInset citation
LatexCommand cite
key "AJAX"

\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Local-database"

\end_inset

Local database
\end_layout

\begin_layout Standard
The best practice is to create a local database on the client (with only
 the data needed, what the client want) using optimistic replications 
\begin_inset CommandInset citation
LatexCommand cite
key "OptimisticReplication"

\end_inset

, this allows to have what commercially is called 
\begin_inset Quotes fld
\end_inset

optimistic UI
\begin_inset Quotes frd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "OptimisticUI"

\end_inset

.
\begin_inset Newline newline
\end_inset

It gives the ability to update the 
\begin_inset Quotes fld
\end_inset

local database
\begin_inset Quotes frd
\end_inset

 (and consequentially the user interface) even if there are network delays
 or if the network is down.
\begin_inset Newline newline
\end_inset

So the developer can call all the methods (get data, put data and so on)
 on the database, seeing the effect, even if there is no connection (often
 called offline mode); of course some server constraints/modifications are
 applied when the network comes back up.
 Some of constraints/modifications applied by the server can be implemented
 in the client such as type constraints, integrity constraints and so on;
 of course the server rechecks everything again.
\end_layout

\begin_layout Standard
Conflicts can occur and different ways exist to solve them 
\begin_inset CommandInset citation
LatexCommand cite
key "OptimisticReplication"

\end_inset

.
 
\begin_inset Newline newline
\end_inset

One of the simplest ways to solve conflict is 
\begin_inset Quotes fld
\end_inset

Last Writes Wins
\begin_inset Quotes frd
\end_inset

, in this way the writing with the highest timestamps is used overwriting
 the concurrent others.
 This approach is used by different systems in implementation of 
\begin_inset Quotes fld
\end_inset

local database
\begin_inset Quotes frd
\end_inset

, the timestamp used is the one of the server when the message is really
 received by the server (not the update time by client that can be very
 old due to network delays).
 Of course this approach is reliable when there are masters/supernodes,
 in other cases techniques that take in consideration consensus are needed.
\end_layout

\end_body
\end_document
