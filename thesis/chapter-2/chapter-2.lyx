#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\options openright
\use_default_options false
\master ../thesis.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding T1
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Indice
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language french
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:Realtime-databases-stack"

\end_inset

NoSQL 
\begin_inset Quotes fld
\end_inset

Realtime
\begin_inset Quotes frd
\end_inset

 databases stack
\end_layout

\begin_layout Standard
As we have seen in the previous section with a standard HTTP application
 stack we can create a 
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 application, so why were these NoSQL databases born?
\begin_inset Newline newline
\end_inset

They were born to increase the performance and to allow to send realtime
 notifications in an easier way (without implementing manually the entire
 stack), we can see analogous tiers shown in figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Modern-web-application"

\end_inset

:
\end_layout

\begin_layout Itemize
DB: they use an unstructured data model, like a NoSQL database explained
 in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:NoSQL-databases"

\end_inset

, with a lot of advantages:
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
the database can be easily partitioned and distributed over different nodes,
 an important property as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Partitioning-and-Distribution"

\end_inset


\end_layout

\begin_layout Itemize
the client can 
\begin_inset Quotes fld
\end_inset

subscribe
\begin_inset Quotes frd
\end_inset

 only to a small portion of the data as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:JSON"

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Application: they create a distributed Publish/Subscribe server, the distributio
n is not an easy task as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Distribution"

\end_inset


\end_layout

\begin_layout Itemize
Client: they provide client libraries to use Publish/Subscribe in an efficient
 and transparent way using what is called 
\begin_inset Quotes fld
\end_inset

local database
\begin_inset Quotes frd
\end_inset

 as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Client-best-practices"

\end_inset


\end_layout

\begin_layout Standard
Everything can be implemented in a serverless approach as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Serverless"

\end_inset

, an efficient approach that can also give a lot of economic advantages
 in different situations.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:NoSQL-databases"

\end_inset

NoSQL databases
\end_layout

\begin_layout Standard
A NoSQL database is an unstructured database, it can support a subset of
 the SQL instructions (but it is not mandatory).
 They were born to create scalable databases for Big Data applications,
 in fact they can have 
\begin_inset Quotes fld
\end_inset

multiple masters
\begin_inset Quotes frd
\end_inset

 support (the ability to write data using different master nodes) 
\begin_inset CommandInset citation
LatexCommand cite
key "NoSQL"

\end_inset

.
\end_layout

\begin_layout Standard
They can be easily partitioned but in order to ensure this efficiently they
 have to renounce to the Consistency or to the Availability as shown in
 the figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:-Database-triangle"

\end_inset

 (more details are explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Consistency,-Partition-tolerance"

\end_inset

), we will see more details on the chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:technologies"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ../chapter-1/db-triangle.png
	width 80col%
	clip

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "fig:-Database-triangle"

\end_inset

Database triangle
\begin_inset CommandInset citation
LatexCommand cite
key "DBTriangle"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Data are stored in JSON format or other unstructured formats, the advantages
 and structure of JSON are explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:JSON"

\end_inset

.
\begin_inset Newline newline
\end_inset

Data are organized in 
\begin_inset Quotes fld
\end_inset

documents
\begin_inset Quotes frd
\end_inset

 not tables 
\begin_inset CommandInset citation
LatexCommand cite
key "CAPNoSQL"

\end_inset

.
 Each document is something that can contain data in JSON format, file or
 other things.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:JSON"

\end_inset

JSON
\end_layout

\begin_layout Standard
JSON (JavaScript Object Notation) is an easy standard to store data 
\begin_inset CommandInset citation
LatexCommand cite
key "JSON"

\end_inset

, it is not so powerful like XML but it is simpler so the computation is
 faster 
\begin_inset CommandInset citation
LatexCommand cite
key "JSONvsXML"

\end_inset

.
 On listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Simple-JSON-example"

\end_inset

 there is a simple example of a JSON structure.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\ttfamily},breaklines=true,commentstyle={\color{purple!60!black}},extendedchars=true,identifierstyle={\color{blue!50!black}},keywordstyle={\bfseries\color{green!50!black}},language=JavaScript,numbers=left,numberstyle={\footnotesize},showstringspaces=false,stringstyle={\color{orange!40!black}},tabsize=4,xleftmargin=2em"
inline false
status open

\begin_layout Plain Layout

\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "lis:Simple-JSON-example"

\end_inset

Simple JSON example
\end_layout

\end_inset

{
\end_layout

\begin_layout Plain Layout

	"main_array":[
\end_layout

\begin_layout Plain Layout

		[
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				"title": "Element 11"
\end_layout

\begin_layout Plain Layout

			},
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				"title": "Element 12"
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		],
\end_layout

\begin_layout Plain Layout

		[
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				"title": "Element 21"
\end_layout

\begin_layout Plain Layout

			},
\end_layout

\begin_layout Plain Layout

			{
\end_layout

\begin_layout Plain Layout

				"title": "Element 22"
\end_layout

\begin_layout Plain Layout

			}
\end_layout

\begin_layout Plain Layout

		]
\end_layout

\begin_layout Plain Layout

	]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
On the JSON structure there can be simple types, array or objects, in the
 previous example (listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Simple-JSON-example"

\end_inset

) we have:
\end_layout

\begin_layout Itemize
main object
\end_layout

\begin_deeper
\begin_layout Itemize
an array (called 
\begin_inset Quotes fld
\end_inset

main_array
\begin_inset Quotes frd
\end_inset

)
\end_layout

\begin_deeper
\begin_layout Itemize
two arrays
\end_layout

\begin_deeper
\begin_layout Itemize
two objects (with 
\begin_inset Quotes fld
\end_inset

title
\begin_inset Quotes frd
\end_inset

 property)
\end_layout

\end_deeper
\end_deeper
\end_deeper
\begin_layout Standard
So in a NoSQL database a 
\begin_inset Quotes fld
\end_inset

document
\begin_inset Quotes frd
\end_inset

 is composed by a JSON data like that.
 This structure is a very powerful structure that allows to store a lot
 of complex structures.
\end_layout

\begin_layout Standard
A simple example can be a system where we have some users, each of them
 with a complex structure, each user is stored as object in a main array.
\begin_inset Newline newline
\end_inset

We will see this case and others on the chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:class-of-applications"

\end_inset

.
\end_layout

\begin_layout Standard
As introduced in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:RESTful"

\end_inset

 the RESTful is a good protocol for JSON and, in general, NoSQL databases
 
\begin_inset CommandInset citation
LatexCommand cite
key "RESTNOSQL"

\end_inset

.
\end_layout

\begin_layout Standard
It is easy to see how this structure can be useful to 
\begin_inset Quotes fld
\end_inset

subscribe
\begin_inset Quotes frd
\end_inset

 only to a portion of data, to a 
\begin_inset Quotes fld
\end_inset

path
\begin_inset Quotes frd
\end_inset

.
 For example using a structure like the one used in listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Simple-JSON-example"

\end_inset

, we can subscribe to the second element of the main array (an inner array)
 then we receive notification when an object (or other inner elements also
 complex elements) is:
\end_layout

\begin_layout Itemize
added
\end_layout

\begin_layout Itemize
removed
\end_layout

\begin_layout Itemize
updated
\end_layout

\begin_layout Standard
We see better what it means to 
\begin_inset Quotes fld
\end_inset

subscribe
\begin_inset Quotes frd
\end_inset

 to a specif 
\begin_inset Quotes fld
\end_inset

path
\begin_inset Quotes frd
\end_inset

 of the JSON structure in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Client-best-practices"

\end_inset

.
\end_layout

\begin_layout Standard
If the 
\begin_inset Quotes fld
\end_inset

subscription
\begin_inset Quotes frd
\end_inset

 is just to one level of the structure, the system is so called 
\begin_inset Quotes fld
\end_inset

key-value
\begin_inset Quotes frd
\end_inset

 not 
\begin_inset Quotes fld
\end_inset

document
\begin_inset Quotes frd
\end_inset

 based, where the value can be also a JSON document 
\begin_inset CommandInset citation
LatexCommand cite
key "CAPNoSQL"

\end_inset

.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Consistency,-Partition-tolerance"

\end_inset

Consistency, Partition tolerance, Availability
\end_layout

\begin_layout Standard
The figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:-Database-triangle"

\end_inset

 shows the CAP theorem applied to the databases, it says that in the distributed
 systems only two of the following three properties can be guaranteed 
\begin_inset CommandInset citation
LatexCommand cite
key "CAPNoSQL,CAP"

\end_inset

:
\end_layout

\begin_layout Itemize
Consistency: all nodes receive the most recent data (write)
\end_layout

\begin_layout Itemize
Availability: all requests receive a response with data (this does not ensure
 that data are the newest)
\end_layout

\begin_layout Itemize
Partition tolerance: the system works properly even if data are partitioned
 among nodes, also if some of them are unreachable
\end_layout

\begin_layout Standard
Of course if there are no network errors all properties are hold.
\begin_inset Newline newline
\end_inset

In the distributed systems the main issue is the synchronization among nodes:
 there is no common clock, so it is not so easy to determine the order of
 commits.
\end_layout

\begin_layout Standard
ACID (Atomicity, Consistency, Isolation, Durability) databases (traditional
 relational databases) choose Availability and Consistency 
\begin_inset CommandInset citation
LatexCommand cite
key "CAPNoSQL"

\end_inset

.
\begin_inset Newline newline
\end_inset

Instead NoSQL, often, chooses Availability and Partition tolerance or Consistenc
y and Partition tolerance 
\begin_inset CommandInset citation
LatexCommand cite
key "CAPNoSQL"

\end_inset

.
 In the chapter 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:technologies"

\end_inset

 we will see NoSQL databases of both types.
\end_layout

\begin_layout Paragraph
\begin_inset CommandInset label
LatexCommand label
name "par:Eventual-consistency"

\end_inset

Eventual consistency
\end_layout

\begin_layout Standard
So, often, in NoSQL the 
\begin_inset Quotes fld
\end_inset

strong consistency
\begin_inset Quotes frd
\end_inset

 is not implemented, but instead the 
\begin_inset Quotes fld
\end_inset

eventual consistency
\begin_inset Quotes frd
\end_inset

 is implemented: 
\begin_inset Quotes fld
\end_inset

the storage system guarantees that if no new updates are made to the object,
 eventually all accesses will return the last updated value
\begin_inset Quotes frd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "EventuallyConsistent"

\end_inset

.
\end_layout

\begin_layout Paragraph
\begin_inset CommandInset label
LatexCommand label
name "par:CAP-validity"

\end_inset

Today validity
\end_layout

\begin_layout Standard
Today there are new things to consider like partitioned cluster over WAN,
 that can cause different issues such as high latency, so CAP theorem is
 not enough to classify these new situations.
 New classifications are proposed like 
\begin_inset Quotes fld
\end_inset

PACELC
\begin_inset Quotes frd
\end_inset

 to solve these issues 
\begin_inset CommandInset citation
LatexCommand cite
key "CAPValidity"

\end_inset

.
 
\series bold
TODO ADD
\series default

\begin_inset Newline newline
\end_inset

But since this classification is not used yet by a lot of commercial and
 non systems in the next chapters CAP classification will be used, since
 used 
\begin_inset Quotes fld
\end_inset

PACELC
\begin_inset Quotes frd
\end_inset

 would cause the classification inconsistent (since some systems are not
 classified under it).
 Moreover some commercial systems do not give further details to make this
 classification by yourself.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Partitioning-and-Distribution"

\end_inset

Partitioning and Distribution
\end_layout

\begin_layout Standard
There are some systems that use both ideas.
 For example HDFS (a distributed file system) replicates the data among
 nodes and it partitions data among nodes 
\begin_inset CommandInset citation
LatexCommand cite
key "HDFS"

\end_inset

.
 So a chunk of data is replicated some times but it is not present in all
 nodes.
 A group of nodes is called 
\begin_inset Quotes fld
\end_inset

cluster
\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Standard
To elaborate data in a distributed environment one simple, powerful and
 commonly programming model is: MapReduce (shortly explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:MapReduce"

\end_inset

).
\end_layout

\begin_layout Standard
The two main patterns to structure an architecture are: 
\begin_inset Quotes fld
\end_inset

multi master
\begin_inset Quotes frd
\end_inset

 and 
\begin_inset Quotes fld
\end_inset

master-salves
\begin_inset Quotes frd
\end_inset

 explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Multi-Master-&-Master-Slaves"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Partitioning
\end_layout

\begin_layout Standard
Partitioning data among different nodes means to split data into chunks
 according to some rules defined and to put different chunks into different
 nodes 
\begin_inset CommandInset citation
LatexCommand cite
key "CAPNoSQL,NoSQL"

\end_inset

.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Distribution"

\end_inset

Distribution
\end_layout

\begin_layout Standard
The distribution is the replication of the infrastructure among different
 nodes, each node does the same thing.
 It is not a so easy concept, in fact there is the synchronization problem
 (formally known as consistency as shown by the 
\begin_inset Quotes fld
\end_inset

CAP
\begin_inset Quotes frd
\end_inset

 theorem explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Consistency,-Partition-tolerance"

\end_inset

) 
\begin_inset CommandInset citation
LatexCommand cite
key "CAP"

\end_inset

 for example in the following scenarios:
\end_layout

\begin_layout Itemize
Commit data in a distributed database: the problem is to find the correct
 commits order since there is no common clock
\end_layout

\begin_layout Itemize
Publish/Subscribe: in a Publish/Subscribe application distributed among
 different nodes, how a published data in a node is sent to all the subscribed
 clients also the ones subscribed on other nodes?
\end_layout

\begin_layout Standard
As said previously in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:NoSQL-databases"

\end_inset

 the NoSQL database are distributed.
 Also the master node can be distributed, so the client can commit on different
 nodes.
 This increases the performance, since there are no saturation issues of
 the server or of the locks needed to write data (commit) 
\begin_inset CommandInset citation
LatexCommand cite
key "NoSQL"

\end_inset

.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:MapReduce"

\end_inset

MapReduce
\end_layout

\begin_layout Standard
MapReduce is a programming model where data are split among different nodes
 and are elaborated by different nodes 
\begin_inset CommandInset citation
LatexCommand cite
key "MapReduce"

\end_inset

.
 It is composed by three main actions:
\end_layout

\begin_layout Enumerate
Map: filtering and sorting data
\end_layout

\begin_layout Enumerate
Shuffle: group data by key and send data with the same key to the same reducer
 node
\end_layout

\begin_layout Enumerate
Reduce: summary operations
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Multi-Master-&-Master-Slaves"

\end_inset

Multi Master & Master-Slaves
\end_layout

\begin_layout Paragraph
Multi Master
\end_layout

\begin_layout Standard
All data can be written in every node of the cluster that replicates them
 to other nodes 
\begin_inset CommandInset citation
LatexCommand cite
key "MultiMasterReplication"

\end_inset

.
 Of course in this kind of architecture there can be issues due to the 
\begin_inset Quotes fld
\end_inset

CAP
\begin_inset Quotes frd
\end_inset

 theorem as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Distribution"

\end_inset

.
\end_layout

\begin_layout Paragraph
Master-Slaves
\end_layout

\begin_layout Standard
All data are written in one node that replicates them to the other that
 can be used only in 
\begin_inset Quotes fld
\end_inset

read only mode
\begin_inset Quotes frd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "MasterSlaveReplication"

\end_inset

.
 Of course in this kind of architecture there are less issues than all the
 issues explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Distribution"

\end_inset

.
 There can be still issues due to 
\begin_inset Quotes fld
\end_inset

Availability
\begin_inset Quotes frd
\end_inset

 as explained by the 
\begin_inset Quotes fld
\end_inset

CAP
\begin_inset Quotes frd
\end_inset

 theorem explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Consistency,-Partition-tolerance"

\end_inset

.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Client-best-practices"

\end_inset

Client best practices
\end_layout

\begin_layout Standard
In this sub section we will see the best practices used in these kind of
 applications from the client point of view.
 Some choices, like data returned in some cases, can be imposed by the server
 technology chosen.
\end_layout

\begin_layout Standard
In tests, benchmarks and examples in the next chapters we will use EcmaScript
 5.0 (in some cases we will use EcmaScript 6.0), commonly known with its dialect
 name: javascript, to use libraries/frameworks.
 In fact the most known EcmaScript interpreter: V8 is very efficient for
 event driven programs, it is the interpreter used by the desktop porting
 that we will use: nodejs 
\begin_inset CommandInset citation
LatexCommand cite
key "NodeEventDriven"

\end_inset

.
 This efficiency is due to a good Just in Time compiler written in C 
\begin_inset CommandInset citation
LatexCommand cite
key "V8"

\end_inset

.
 All server technologies chosen analyzed in the next chapters have EcmaScript
 clients, of course we can create clients in other languages since the protocols
 used are standard and opened.
 EcmaScript is a language where event driven approach is easy to implement,
 in fact the language has the fundamentals to execute the asynchronous code
 since it has the callbacks 
\begin_inset CommandInset citation
LatexCommand cite
key "SyncAsync,AJAX"

\end_inset

.
\series bold

\begin_inset Newline newline
\end_inset


\series default
Moreover EcamScript is executed in only one thread, also the callbacks are
 executed in this thread.
 But some operations like network requests, database connections and so
 on are executed by other threads in background (the result is passed to
 the callback called in the main thread).
 If there is no CPU intensive code, this approach is very efficient and
 solves problems due to race conditions 
\begin_inset CommandInset citation
LatexCommand cite
key "NodeEventDriven"

\end_inset

.
\series bold

\begin_inset Newline newline
\end_inset


\series default
Nodejs has also a standard packet manager called NPM, with a lot of libraries,
 this allows to write small examples with only the code needed to understand,
 the other parts are done by the libraries.
\series bold

\begin_inset Newline newline
\end_inset


\series default
Furthermore JSON, as the acronym suggests, is derived from javascript.
 In fact the javascript can parse it easily and JSON objects/arrays become
 javascript native objects/arrays.
 So we can access to them in a native way without calling parsing methods
 to iterate the structure or without mapping the JSON into already defined
 classes (i.e.
 deserialize it to objects), like other languages do like JAVA 
\begin_inset CommandInset citation
LatexCommand cite
key "JAVAJSON"

\end_inset

, in fact both approaches are not easily adaptable to structure changes.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Event-driven-approach"

\end_inset

Event driven approach
\end_layout

\begin_layout Standard
On algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Event-driven-retrieve"

\end_inset

 we show a common and simple realtime retrieve of data in event driven approach.
 The basic idea of event driven approach is to call a callback when an event
 is fired, a known example of event driven programming is programming for
 desktop interfaces where the events are the user inputs.
\begin_inset Newline newline
\end_inset

Of course this is not the only approach available but it is easy to understand
 how it is very useful in asynchronous applications like 
\begin_inset Quotes fld
\end_inset

realtime
\begin_inset Quotes frd
\end_inset

 applications that we discuss in this thesis.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:Event-driven-retrieve"

\end_inset

Event driven retrieve of data
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout

	
\backslash
State $db 
\backslash
gets 
\backslash
Call{connect}{DB
\backslash
_ADDRESS}$ 
\backslash
Comment{Connect to DB}
\end_layout

\begin_layout Plain Layout

	
\backslash
State $document 
\backslash
gets 
\backslash
Call{selectDocument}{db, DOCUMENT}$ 
\backslash
Comment{Select document}
\end_layout

\begin_layout Plain Layout

	
\backslash
State $
\backslash
Call{onChange}{document, PATH, CALLBACK}$ 
\backslash
Comment{Subscribe to change events}
\end_layout

\begin_layout Plain Layout

	
\backslash
Procedure{callback}{newVal, oldVal}
\end_layout

\begin_layout Plain Layout

		
\backslash
State $
\backslash
Call{log}{oldVal}$ 
\backslash
Comment{Log new value of the path}
\end_layout

\begin_layout Plain Layout

		
\backslash
State $
\backslash
Call{log}{newVal}$ 
\backslash
Comment{Log old value of the path}
\end_layout

\begin_layout Plain Layout

	
\backslash
EndProcedure
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The basic idea is to subscribe a callback to change events of a specif path
 of a document, thinking of JSON documents the path is a reference to a
 specif level of the JSON document.
 For example a path for the JSON listing 
\begin_inset CommandInset ref
LatexCommand ref
reference "lis:Simple-JSON-example"

\end_inset

 can be 
\begin_inset Quotes fld
\end_inset

/main_array/0/
\begin_inset Quotes frd
\end_inset

 to subscribe to change events of the first array inside main array.
\begin_inset Newline newline
\end_inset

On the callback the entire new path can be passed or only the part changed,
 in the case of an array only the child changed.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:RESTful-Approach"

\end_inset

RESTful Approach
\end_layout

\begin_layout Standard
What we said previously in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Event-driven-approach"

\end_inset

 for path is valid also for RESTful URI as introduced in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:RESTful"

\end_inset

.
 RESTful is useful to post/put/delete data and to retrieve them in an synchronou
s way, synchronous retrieve can be useful to populate local databases (explained
 in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Local-database"

\end_inset

) at the beginning, in fact RESTful is not compatible with asynchronous
 requests.
 There is no reason to do this kind of operations in an asynchronous way,
 of course they can be done via a websocket connection, but they are done
 in a sort of synchronous way.
\end_layout

\begin_layout Standard
So the best practice is to use RESTful for all synchronous operations, let
 the possibility to use RESTful get all data or a portion of them, but give
 also an asynchronous
\end_layout

\begin_layout Standard
interface integrated with the event driven approach like websocket.
\end_layout

\begin_layout Standard
Of course since JavaScript has asynchronous operations support the result
 of these synchronous operations is returned via a callback.
 These operations are synchronous, in the meaning that after the request
 is sent a response is returned immediately, but there are network delays,
 for that reason the code is executed in an asynchronous way 
\begin_inset CommandInset citation
LatexCommand cite
key "AJAX"

\end_inset

.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Local-database"

\end_inset

Local database
\end_layout

\begin_layout Standard
The best practice is to create a local database on the client (with only
 the data needed) using optimistic replications 
\begin_inset CommandInset citation
LatexCommand cite
key "OptimisticReplication"

\end_inset

, this allows to have what commercially is called 
\begin_inset Quotes fld
\end_inset

optimistic UI
\begin_inset Quotes frd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "OptimisticUI"

\end_inset

:
\begin_inset Newline newline
\end_inset

It gives the ability to update the 
\begin_inset Quotes fld
\end_inset

local database
\begin_inset Quotes frd
\end_inset

 (and consequentially the user interface) even if there are network delays
 or if the network is down.
\begin_inset Newline newline
\end_inset

So the developer can call all the methods on the database, seeing the effect,
 even if there is no connection (often called offline mode); of course some
 server constraints/modifications are applied when the network comes back
 up.
 Some of constraints/modifications applied by the server can be implemented
 in the client such as type constraints, integrity constraints and so on;
 of course the server rechecks everything again.
\end_layout

\begin_layout Standard
Conflicts can occur and different ways exist to solve them 
\begin_inset CommandInset citation
LatexCommand cite
key "OptimisticReplication"

\end_inset

.
 
\begin_inset Newline newline
\end_inset

One of the simplest ways to solve conflict is 
\begin_inset Quotes fld
\end_inset

Last Writes Wins
\begin_inset Quotes frd
\end_inset

, in this way the writing with the highest timestamps is used overwriting
 the concurrent others.
 This approach is used by different systems in implementation of 
\begin_inset Quotes fld
\end_inset

local database
\begin_inset Quotes frd
\end_inset

, the timestamp used is the one of the server when the message is really
 received by the server (not the update time by client that can be very
 old due to network delays).
 Of course this approach is reliable when there are masters/supernodes,
 in other cases techniques that take in consideration consensus are needed.
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sec:Serverless"

\end_inset

Serverless
\end_layout

\begin_layout Standard
A serverless is a cloud computing architecture, where the developer has
 not to think about the infrastructure.
 It is something at the middle between 
\begin_inset Quotes fld
\end_inset

Platform as a Service
\begin_inset Quotes frd
\end_inset

 and 
\begin_inset Quotes fld
\end_inset

Software as a Service
\begin_inset Quotes frd
\end_inset

, for that reason it is also known as 
\begin_inset Quotes fld
\end_inset

Function as a Service
\begin_inset Quotes frd
\end_inset

.
\begin_inset Newline newline
\end_inset

The serverless idea is a general idea that can be implemented for different
 things, a classic implementation is for file systems 
\begin_inset CommandInset citation
LatexCommand cite
key "ServerlessFilesystem"

\end_inset

.
\end_layout

\begin_layout Standard
In serverless architecture the developer has to think only to develop the
 application without thinking how to scale the infrastructure, how to store
 data in a secure way and so on.
 In serveless architecture the developer has not to develop a real server,
 the server is already set, he has only to configure it and eventually develop
 some small extensions (in the database case the extension can be simply
 the triggers).
\begin_inset Newline newline
\end_inset

Like 
\begin_inset Quotes fld
\end_inset

Function as a Service
\begin_inset Quotes frd
\end_inset

 suggests we can have also systems where we have to develop just a piece
 of code, a function, that is executed in an 
\begin_inset Quotes fld
\end_inset

unknown
\begin_inset Quotes frd
\end_inset

 infrastructure, where we have not to think about scalability, we pay just
 for usage.
 For example we pay the number of execution of that function, this is the
 way used by 
\begin_inset Quotes fld
\end_inset

Amazon AWS
\begin_inset Quotes frd
\end_inset

 implementation: 
\begin_inset Quotes fld
\end_inset

AWS Lambda
\begin_inset Quotes frd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "AWSLambda,AWSLambdaPricing"

\end_inset

.
 This is a big advantage for the user, because there is an instant scalability
 that there is not on 
\begin_inset Quotes fld
\end_inset

Platform as a Service
\begin_inset Quotes frd
\end_inset

 as we will see on 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Platform-as-a"

\end_inset

.
\end_layout

\begin_layout Standard
As we will see on 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Main-Realtime-Databases"

\end_inset

 this kind of architecture is entirely developed on cloud architecture and
 partially developed on Open Source architectures, in open source architecture
 we have the facility to configure and develop the server but we do not
 have an easy scalability like the cloud systems.
\end_layout

\begin_layout Standard
After we will see 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Software-as-a"

\end_inset

 we will know how the difference among these three kinds of architecture
 is minimal and that often there is overlapping among the architectures.
\begin_inset Newline newline
\end_inset

An example of overlapping is 
\begin_inset Quotes fld
\end_inset

Salesforce.com
\begin_inset Quotes frd
\end_inset

, a CRM (customer relationship management) service born like a 
\begin_inset Quotes fld
\end_inset

Software as a Service
\begin_inset Quotes frd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "SAAS"

\end_inset

.
 But it has become a sort of Serverless architecture to build business applicati
ons, it has also bought 
\begin_inset Quotes fld
\end_inset

Heroku
\begin_inset Quotes frd
\end_inset

 a 
\begin_inset Quotes fld
\end_inset

Platform as a Service
\begin_inset Quotes frd
\end_inset

 company.
 However, even if now it is like a serverless service, the price system
 has remained the same as that of 
\begin_inset Quotes fld
\end_inset

Software as a Service
\begin_inset Quotes frd
\end_inset

 system, where you do not pay the usage, you pay for accounts and each account
 has some limits 
\begin_inset CommandInset citation
LatexCommand cite
key "SalesforcePricing"

\end_inset

.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Platform-as-a"

\end_inset

Platform as a Service
\end_layout

\begin_layout Standard
\begin_inset Quotes fld
\end_inset

Platform as a Service
\begin_inset Quotes frd
\end_inset

 is a cloud computing architecture where the developer has not to think
 about infrastructure, he chooses the platform where to develop that is
 automatically configured and ready to use 
\begin_inset CommandInset citation
LatexCommand cite
key "PAAS"

\end_inset

.
 In this kind of architecture the developer has to choose how to scale (it
 can be an automatic process) but in an easy way, often he has only to choose
 the number of nodes.
\end_layout

\begin_layout Standard
One of the most known 
\begin_inset Quotes fld
\end_inset

Platform as a Service
\begin_inset Quotes frd
\end_inset

 service is 
\begin_inset Quotes fld
\end_inset

Heroku
\begin_inset Quotes frd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Heroku"

\end_inset

, comparing the price system of 
\begin_inset Quotes fld
\end_inset

Heroku
\begin_inset Quotes frd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "HerokuPricing"

\end_inset

 with the price system of 
\begin_inset Quotes fld
\end_inset

AWS Lambda
\begin_inset Quotes frd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "AWSLambdaPricing"

\end_inset

 we can see that in 
\begin_inset Quotes fld
\end_inset

Heroku
\begin_inset Quotes frd
\end_inset

 we pay for number of nodes per seconds, while in 
\begin_inset Quotes fld
\end_inset

AWS Lambda
\begin_inset Quotes frd
\end_inset

 we pay just for execution time.
 In 
\begin_inset Quotes fld
\end_inset

AWS Lambda
\begin_inset Quotes frd
\end_inset

 we have not to do anything to execute just one 
\begin_inset Quotes fld
\end_inset

function
\begin_inset Quotes frd
\end_inset

 per second or thousands per second, while on 
\begin_inset Quotes fld
\end_inset

Heroku
\begin_inset Quotes frd
\end_inset

 we have to set the right number of nodes or set a correct strategy to dynamical
ly create/remove nodes.
 So the serverless approach can reach the maximum grade of sharing resources
 in cloud computing.
\end_layout

\begin_layout Standard
For what concerns the concept of platform ready to use to develop the serverless
 architecture is similar to 
\begin_inset Quotes fld
\end_inset

Platform as a Service
\begin_inset Quotes frd
\end_inset

 but it is different for other things like scalability as we have seen with
 
\begin_inset Quotes fld
\end_inset

AWS Lambda
\begin_inset Quotes frd
\end_inset

 example.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "subsec:Software-as-a"

\end_inset

Software as a Service
\end_layout

\begin_layout Standard
\begin_inset Quotes fld
\end_inset

Software as a service
\begin_inset Quotes frd
\end_inset

 is a cloud computing architecture where there is no need or possibility
 to develop anything 
\begin_inset CommandInset citation
LatexCommand cite
key "SAAS"

\end_inset

.
 One classic example is a webmail service, that can be configured for a
 private company.
\end_layout

\begin_layout Standard
One of the most known 
\begin_inset Quotes fld
\end_inset

Software as a Service
\begin_inset Quotes frd
\end_inset

 service is 
\begin_inset Quotes fld
\end_inset

Google apps for work
\begin_inset Quotes frd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "GoogleWork"

\end_inset

, a service where the employees of a company have access to company mail,
 company docs, company cloud storage and so on; everything is done only
 by configuring a system without developing anything.
 The price system of 
\begin_inset Quotes fld
\end_inset

Google apps for work
\begin_inset Quotes frd
\end_inset

 is a system where the company has to pay for the number of users not for
 the usage 
\begin_inset CommandInset citation
LatexCommand cite
key "GoogleWorkPricing"

\end_inset

, an approach completely different from other cloud systems, but it is a
 good approach for companies because in that way they are able to predict
 the cost in a reliable way.
\end_layout

\begin_layout Standard
The serverless approach is very similar to 
\begin_inset Quotes fld
\end_inset

Software as a Service
\begin_inset Quotes frd
\end_inset

 since the developer has not to think about the infrastructure or how to
 build a reliable server, but instead of the 
\begin_inset Quotes fld
\end_inset

Software as a Service
\begin_inset Quotes frd
\end_inset

 in the serverless architecture the developer can develop something, not
 only configure.
\end_layout

\end_body
\end_document
